export const patch =
"diff --git a/lib/normalize-options.js b/lib/normalize-options.js\nindex 4b56904..3859dfa 100644\nsemver exclusivity ^1.9\n--- a/lib/normalize-options.js\n+++ b/lib/normalize-options.js\n@@ -1,10 +1,61 @@\n-module.exports = function (x, opts) {\n-    /**\n-     * This file is purposefully a passthrough. It's expected that third-party\n-     * environments will override it at runtime in order to inject special logic\n-     * into `resolve` (by manipulating the options). One such example is the PnP\n-     * code path in Yarn.\n-     */\n-\n-    return opts || {};\n+module.exports = function (_, opts) {\n+  opts = opts || {};\n+\n+  if (opts.forceNodeResolution || !process.versions.pnp)\n+    return opts;\n+\n+  if (opts.packageIterator || opts.paths)\n+    throw new Error(`The 'packageIterator' and 'paths' options cannot be used in PnP environments. Set 'forceNodeResolution: true' if absolutely needed, or branch on process.versions.pnp otherwise.`);\n+\n+  const pnp = require(`pnpapi`);\n+\n+  /**\n+   * @param request {string}\n+   * @param basedir {string}\n+   * @param getCandidates {() => Array<string>}\n+   * @param opts {any}\n+   */\n+  opts.packageIterator = function (request, basedir, getCandidates, opts) {\n+    // Extract the name of the package being requested (1=full name, 2=scope name, 3=local name)\n+    const parts = request.match(/^((?:(@[^\\/]+)\\/)?([^\\/]+))/);\n+    if (!parts)\n+      throw new Error(`Assertion failed: Expected the \"resolve\" package to call the \"paths\" callback with package names only (got \"${request}\")`);\n+\n+    // Make sure that basedir ends with a slash\n+    if (basedir.charAt(basedir.length - 1) !== `/`)\n+      basedir = path.join(basedir, `/`);\n+\n+    const api = pnp.findApiFromPath(basedir);\n+    if (api === null)\n+      return getCandidates();\n+\n+    // This is guaranteed to return the path to the \"package.json\" file from the given package\n+    const manifestPath = api.resolveToUnqualified(`${parts[1]}/package.json`, basedir, {\n+      considerBuiltins: false,\n+    });\n+\n+    if (manifestPath === null)\n+      throw new Error(`Assertion failed: The resolution thinks that \"${parts[1]}\" is a Node builtin`);\n+\n+    // Strip the package.json to get the package folder\n+    return [path.dirname(manifestPath)];\n+  };\n+\n+  opts.paths = function (request, basedir, getNodeModulePaths, opts) {\n+    if (opts.packageIterator)\n+      return getNodeModulePaths();\n+\n+    return opts.packageIterator(request, basedir, () => [], opts).map(path => {\n+      // Stip the local named folder\n+      let nodeModules = path.dirname(manifestPath);\n+\n+      // Strip the scope named folder if needed\n+      if (request.match(/^@[^\\/]+)\\//))\n+        nodeModules = path.dirname(nodeModules);\n+\n+      return [nodeModules];\n+    });\n+  };\n+\n+  return opts;\n };\n"
;
