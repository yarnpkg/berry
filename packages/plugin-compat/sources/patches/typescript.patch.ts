export const patch =
"diff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..c4a080b2c8 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -22576,21 +22576,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22697,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23072,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23519,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..057ea079ad 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -27790,24 +27790,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27922,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28408,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28909,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..cf3e054327 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -27940,24 +27940,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28072,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28558,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29059,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..92c195a616 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..0f0db98cbb 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..cfa1e84496 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -27779,24 +27779,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27911,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28397,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28898,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..969fcb8109 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -2977,6 +2977,9 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n                 }\n@@ -22576,21 +22579,51 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22703,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,16 +23078,22 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -23487,6 +23528,55 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -81887,6 +81977,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -81917,7 +82010,7 @@ var ts;\n             var moduleSpecifier = packageNameOnly ? moduleFileName : getDirectoryOrExtensionlessFileName(moduleFileName);\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..620f28b2cd 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -5070,6 +5070,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -27790,24 +27795,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27930,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,17 +28416,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -28876,6 +28920,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99548,6 +99654,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99582,7 +99692,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -123974,11 +124086,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -123986,6 +124115,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..34075ee532 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -5220,6 +5220,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -27940,24 +27945,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28080,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,17 +28566,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -29026,6 +29070,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99698,6 +99804,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99732,7 +99842,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124487,11 +124599,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124499,6 +124628,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..1ed3da0fd2 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -5209,6 +5209,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -27929,24 +27934,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28069,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,17 +28555,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -29015,6 +29059,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99793,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99831,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124588,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124617,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..b0bce8c64a 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -5209,6 +5209,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -27929,24 +27934,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28069,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,17 +28555,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -29015,6 +29059,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99793,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99831,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124588,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124617,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..62c581fe5c 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -5059,6 +5059,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -27779,24 +27784,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27919,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,17 +28405,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -28865,6 +28909,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99537,6 +99643,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99571,7 +99681,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex b26f6680f5..00f5d8cca0 100644\nsemver exclusivity >=3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -3386,6 +3386,9 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n                 }\n@@ -23900,21 +23903,51 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -23994,7 +24027,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -24364,16 +24399,22 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -24807,6 +24848,55 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -85916,6 +86006,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -85946,7 +86039,7 @@ var ts;\n             }\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 693b872fa8..576611269d 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -5628,6 +5628,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -29308,24 +29313,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29412,7 +29448,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29893,17 +29931,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -30390,6 +30434,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104159,6 +104265,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104194,7 +104304,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -129482,11 +129594,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -129494,6 +129623,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex d8f708a69c..ceba1780d9 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,17 +30081,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -30540,6 +30584,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104415,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104454,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130117,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130146,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 3a3cfccc27..18bc77223a 100644\nsemver exclusivity >=3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,17 +30081,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -30540,6 +30584,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104415,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104454,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130117,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130146,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex a394c274d8..21e931c0e2 100644\nsemver exclusivity >=3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,17 +30081,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -30540,6 +30584,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104415,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104454,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130117,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130146,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 56b7028dad..9681d7ee59 100644\nsemver exclusivity >=3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -5617,6 +5617,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === \"win32\" || platform === \"win64\") {\n                     return false;\n@@ -29297,24 +29302,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29401,7 +29437,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29882,17 +29920,23 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n+                var isExternalLibraryImport = resolvedValue && isPnpAvailable()\n+                    ? checkPnpExternalLibraryImport(resolvedValue)\n+                    : true;\n+                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n                     var originalPath = path === resolvedValue.path ? undefined : resolvedValue.path;\n                     resolvedValue = __assign(__assign({}, resolvedValue), { path: path, originalPath: originalPath });\n                 }\n-                // For node_modules lookups, get the real path so that multiple accesses to an `npm link`-ed module do not create duplicate files.\n-                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: true } };\n+                return { value: resolvedValue && { resolved: resolvedValue, isExternalLibraryImport: isExternalLibraryImport } };\n             }\n             else {\n                 var _a = ts.normalizePathAndParts(ts.combinePaths(containingDirectory, moduleName)), candidate = _a.path, parts = _a.parts;\n@@ -30379,6 +30423,68 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        return toSearchResult(resolved);\n+    }\n+    function checkPnpExternalLibraryImport(resolvedValue) {\n+        var pnpApi = getPnpApi();\n+        var ownerPackage = pnpApi.findPackageLocator(resolvedValue.path);\n+        if (!ownerPackage) {\n+            return true;\n+        }\n+        var rootLocators = pnpApi.getDependencyTreeRoots();\n+        // External if none of the root locators owns the file\n+        return !rootLocators.some(function (root) {\n+            return root.name === ownerPackage.name && root.reference === ownerPackage.reference;\n+        });\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104148,6 +104254,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104183,7 +104293,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n"
;
