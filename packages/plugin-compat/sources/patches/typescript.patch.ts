export const patch =
`diff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..c4a080b2c8 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -22576,21 +22576,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22697,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23072,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23519,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..057ea079ad 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -27790,24 +27790,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27922,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28408,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28909,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..cf3e054327 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -27940,24 +27940,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28072,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28558,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29059,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..92c195a616 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..0f0db98cbb 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..cfa1e84496 100644\nsemver exclusivity >=3.0 <3.5\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -27779,24 +27779,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27911,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28397,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28898,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex fbb2588645..8ff4e80e9b 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -21553,21 +21553,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -21647,7 +21674,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -22016,9 +22045,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -22460,6 +22492,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 896699e5ad..836359b082 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -26505,24 +26505,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -26609,7 +26637,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -27089,9 +27119,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -27587,6 +27620,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 3e0937a3bf..4433f6c4fa 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -26504,24 +26504,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -26608,7 +26636,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -27088,9 +27118,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -27586,6 +27619,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 5b5ad499a8..2317dbec92 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -26493,24 +26493,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -26597,7 +26625,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -27077,9 +27107,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -27575,6 +27608,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 01f0275f24..7539963133 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -26493,24 +26493,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -26597,7 +26625,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -27077,9 +27107,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -27575,6 +27608,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 37631477ac..81dd92c5e6 100644\nsemver exclusivity >=3.5 <3.6\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -26494,24 +26494,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + "/");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return nmTypes.concat(pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -26598,7 +26626,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -27078,9 +27108,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -27576,6 +27609,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..f160906699 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -2977,6 +2977,9 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n                 }\n@@ -22576,21 +22579,51 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22703,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23078,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23525,46 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -81887,6 +81965,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -81917,7 +81998,7 @@ var ts;\n             var moduleSpecifier = packageNameOnly ? moduleFileName : getDirectoryOrExtensionlessFileName(moduleFileName);\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..bbc4ed3495 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -5070,6 +5070,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -27790,24 +27795,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27930,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28416,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28917,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99548,6 +99641,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99582,7 +99679,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -123974,11 +124073,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -123986,6 +124102,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..0c938ab5d8 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -5220,6 +5220,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -27940,24 +27945,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28080,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28566,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29067,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99698,6 +99791,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99732,7 +99829,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124487,11 +124586,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124499,6 +124615,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..216c753cad 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -5209,6 +5209,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -27929,24 +27934,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28069,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28555,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29056,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99780,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99818,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124575,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124604,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..dadd33c2f3 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -5209,6 +5209,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -27929,24 +27934,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28069,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28555,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29056,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99780,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99818,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124575,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124604,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..af61fe7f6e 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -5059,6 +5059,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -27779,24 +27784,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27919,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28405,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28906,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99537,6 +99630,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99571,7 +99668,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex b26f6680f5..9a48194020 100644\nsemver exclusivity >=3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -3386,6 +3386,9 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n                 }\n@@ -23900,21 +23903,51 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -23994,7 +24027,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -24364,9 +24399,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -24807,6 +24845,46 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -85916,6 +85994,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -85946,7 +86027,7 @@ var ts;\n             }\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 693b872fa8..6604656d71 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -5628,6 +5628,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -29308,24 +29313,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29412,7 +29448,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29893,9 +29931,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30390,6 +30431,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104159,6 +104252,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104194,7 +104291,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -129482,11 +129581,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -129494,6 +129610,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex d8f708a69c..77e4606a9b 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30081,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30581,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104402,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104441,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130104,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130133,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 3a3cfccc27..3f491c03a8 100644\nsemver exclusivity >=3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30081,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30581,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104402,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104441,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130104,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130133,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex a394c274d8..7884dad38f 100644\nsemver exclusivity >=3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -5778,6 +5778,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -29458,24 +29463,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29598,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30081,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30581,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104402,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104441,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130104,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require("pnpapi");\n+        }\n         /**\n          * Don't include something from a \`node_modules\` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a \`node_modules\` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130133,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 56b7028dad..4c4a7b2547 100644\nsemver exclusivity >=3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -5617,6 +5617,11 @@ var ts;\n                     : new Buffer(input, encoding);\n             }\n             function isFileSystemCaseSensitive() {\n+                // The PnP runtime is always case-sensitive\n+                // @ts-ignore\n+                if (process.versions.pnp) {\n+                    return true;\n+                }\n                 // win32\\win64 are case insensitive platforms\n                 if (platform === "win32" || platform === "win64") {\n                     return false;\n@@ -29297,24 +29302,55 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths("node_modules", "@types");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var currentPackage = pnpapi.findPackageLocator(currentDirectory + "/");\n+        if (!currentPackage) {\n+            return [];\n+        }\n+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = "@types/";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29401,7 +29437,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29882,9 +29920,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30379,6 +30420,58 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require("pnpapi");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            var resolution = getPnpApi().resolveToUnqualified(packageName, containingDirectory + "/", { considerBuiltins: false });\n+            return ts.normalizeSlashes(resolution);\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104148,6 +104241,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104183,7 +104280,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n`
;
