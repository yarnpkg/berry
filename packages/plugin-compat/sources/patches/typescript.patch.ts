export const patch =
"diff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..c4a080b2c8 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -22576,21 +22576,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22697,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23072,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23519,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..057ea079ad 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -27790,24 +27790,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27922,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28408,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28909,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..cf3e054327 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -27940,24 +27940,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28072,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28558,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29059,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..92c195a616 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..0f0db98cbb 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..cfa1e84496 100644\nsemver exclusivity >=3.0 <3.6\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -27779,24 +27779,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27911,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28397,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28898,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..543543807b 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -22576,21 +22576,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22697,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23072,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23519,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -81887,6 +81958,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -81917,7 +81991,7 @@ var ts;\n             var moduleSpecifier = packageNameOnly ? moduleFileName : getDirectoryOrExtensionlessFileName(moduleFileName);\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..83510127ae 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -27790,24 +27790,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27922,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28408,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28909,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99548,6 +99632,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99582,7 +99670,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -123974,11 +124064,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -123986,6 +124093,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..4738788997 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -27940,24 +27940,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28072,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28558,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29059,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99698,6 +99782,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99732,7 +99820,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124487,11 +124577,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124499,6 +124606,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..1e5b232e75 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99771,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99809,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124566,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124595,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..f3a9af2320 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -27929,24 +27929,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28061,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28547,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29048,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99687,6 +99771,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99721,7 +99809,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -124476,11 +124566,28 @@ var ts;\n                 }\n             }\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -124488,6 +124595,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..a96c74bf24 100644\nsemver exclusivity >=3.6 <3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -27779,24 +27779,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27911,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28397,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28898,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -99537,6 +99621,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -99571,7 +99659,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\ndiff --git a/lib/tsc.js b/lib/tsc.js\nindex b26f6680f5..d99f53b8f7 100644\nsemver exclusivity >=3.9\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -23900,21 +23900,48 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -23994,7 +24021,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -24364,9 +24393,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -24807,6 +24839,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\n@@ -85916,6 +85987,9 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -85946,7 +86020,7 @@ var ts;\n             }\n             var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 693b872fa8..26320bf45b 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -29308,24 +29308,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29412,7 +29440,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29893,9 +29923,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30390,6 +30423,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104159,6 +104243,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104194,7 +104282,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -129482,11 +129572,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -129494,6 +129601,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex d8f708a69c..2d127afa17 100644\nsemver exclusivity >=3.9\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -29458,24 +29458,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29590,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30073,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30573,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104393,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104432,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130095,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130124,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 3a3cfccc27..b176a7b81a 100644\nsemver exclusivity >=3.9\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -29458,24 +29458,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29590,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30073,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30573,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104393,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104432,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130095,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130124,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex a394c274d8..900281d970 100644\nsemver exclusivity >=3.9\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -29458,24 +29458,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29562,7 +29590,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -30043,9 +30073,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30540,6 +30573,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104309,6 +104393,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104344,7 +104432,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n@@ -130005,11 +130095,28 @@ var ts;\n                     isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);\n             });\n         }\n+        /**\n+         * We only allow PnP to be used as a resolution strategy if TypeScript\n+         * itself is executed under a PnP runtime (and we only allow it to access\n+         * the current PnP runtime, not any on the disk). This ensures that we\n+         * don't execute potentially malicious code that didn't already have a\n+         * chance to be executed (if we're running within the runtime, it means\n+         * that the runtime has already been executed).\n+         * @internal\n+         */\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n+        function getPnpApi() {\n+            // @ts-ignore\n+            return require(\"pnpapi\");\n+        }\n         /**\n          * Don't include something from a `node_modules` that isn't actually reachable by a global import.\n          * A relative import to node_modules is usually a bad idea.\n          */\n-        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+        function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n             // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.\n             var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === \"node_modules\" ? ancestor : undefined; });\n             var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));\n@@ -130017,6 +130124,26 @@ var ts;\n                 || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)\n                 || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));\n         }\n+        function isImportablePathPnp(fromPath, toPath) {\n+            var pnpApi = getPnpApi();\n+            var fromLocator = pnpApi.findPackageLocator(fromPath);\n+            var toLocator = pnpApi.findPackageLocator(toPath);\n+            // eslint-disable-next-line no-null/no-null\n+            if (toLocator === null) {\n+                return false;\n+            }\n+            var fromInfo = pnpApi.getPackageInformation(fromLocator);\n+            var toReference = fromInfo.packageDependencies.get(toLocator.name);\n+            return toReference === toLocator.reference;\n+        }\n+        function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {\n+            if (isPnpAvailable()) {\n+                return isImportablePathPnp(fromPath, toPath);\n+            }\n+            else {\n+                return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);\n+            }\n+        }\n         function moduleSymbolToValidIdentifier(moduleSymbol, target) {\n             return moduleSpecifierToValidIdentifier(ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target);\n         }\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 56b7028dad..e677309c33 100644\nsemver exclusivity >=3.9\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -29297,24 +29297,52 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        // Some TS consumers pass relative paths that aren't normalized\n+        currentDirectory = ts.sys.resolvePath(currentDirectory);\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -29401,7 +29429,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -29882,9 +29912,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -30379,6 +30412,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n@@ -104148,6 +104232,10 @@ var ts;\n                 ? removeExtensionAndIndexPostFix(relativePath, ending, compilerOptions)\n                 : ts.removeFileExtension(relativePath);\n         }\n+        function isPnpAvailable() {\n+            // @ts-ignore\n+            return process.versions.pnp;\n+        }\n         function tryGetModuleNameAsNodeModule(moduleFileName, _a, host, options, packageNameOnly) {\n             var getCanonicalFileName = _a.getCanonicalFileName, sourceDirectory = _a.sourceDirectory;\n             if (!host.fileExists || !host.readFile) {\n@@ -104183,7 +104271,9 @@ var ts;\n             // Get a path that's relative to node_modules or the importing file's path\n             // if node_modules folder is in this folder or any of its parent folders, no need to keep it.\n             var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));\n-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they\n+            // are located in a weird path apparently outside of the source directory\n+            if (!isPnpAvailable() && !(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {\n                 return undefined;\n             }\n             // If the module was found in @types, get the actual Node package name\n"
;
