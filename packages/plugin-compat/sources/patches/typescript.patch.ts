export const patch =
"diff --git a/lib/tsc.js b/lib/tsc.js\nindex d7f749f633..3b98f164c2 100644\n--- a/lib/tsc.js\n+++ b/lib/tsc.js\n@@ -22576,21 +22576,47 @@ var ts;\n         }\n     }\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference) {\n         var traceEnabled = isTraceEnabled(options, host);\n         if (redirectedReference) {\n@@ -22670,7 +22696,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -23043,9 +23071,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -23487,6 +23518,45 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    function isPnpAvailable() {\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), false, state, true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), false, state, true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n var ts;\n (function (ts) {\ndiff --git a/lib/tsserver.js b/lib/tsserver.js\nindex 4ea67ecd85..41c335a9e6 100644\n--- a/lib/tsserver.js\n+++ b/lib/tsserver.js\n@@ -27790,24 +27790,50 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27894,7 +27920,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28378,9 +28406,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28876,6 +28907,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js\nindex 2897a22620..da04c7066d 100644\n--- a/lib/tsserverlibrary.js\n+++ b/lib/tsserverlibrary.js\n@@ -27940,24 +27940,50 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28044,7 +28070,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28528,9 +28556,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29026,6 +29057,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescript.js b/lib/typescript.js\nindex 548ceea966..5e0e8970dc 100644\n--- a/lib/typescript.js\n+++ b/lib/typescript.js\n@@ -27929,24 +27929,50 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28059,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28545,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29046,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typescriptServices.js b/lib/typescriptServices.js\nindex 9046c6f907..7d0d7a9c00 100644\n--- a/lib/typescriptServices.js\n+++ b/lib/typescriptServices.js\n@@ -27929,24 +27929,50 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -28033,7 +28059,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28517,9 +28545,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -29015,6 +29046,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\ndiff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js\nindex 776a2e0a9b..26e5510fa1 100644\n--- a/lib/typingsInstaller.js\n+++ b/lib/typingsInstaller.js\n@@ -27779,24 +27779,50 @@ var ts;\n     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;\n     /**\n      * Returns the path to every node_modules/@types directory from some ancestor directory.\n-     * Returns undefined if there are none.\n      */\n-    function getDefaultTypeRoots(currentDirectory, host) {\n+    function getNodeModulesTypeRoots(currentDirectory, host) {\n         if (!host.directoryExists) {\n             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];\n             // And if it doesn't exist, tough.\n         }\n-        var typeRoots;\n+        var typeRoots = [];\n         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {\n             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);\n             if (host.directoryExists(atTypes)) {\n-                (typeRoots || (typeRoots = [])).push(atTypes);\n+                typeRoots.push(atTypes);\n             }\n             return undefined;\n         });\n         return typeRoots;\n     }\n     var nodeModulesAtTypes = ts.combinePaths(\"node_modules\", \"@types\");\n+    function getPnpTypeRoots(currentDirectory) {\n+        if (!isPnpAvailable()) {\n+            return [];\n+        }\n+        var pnpapi = getPnpApi();\n+        var locator = pnpapi.findPackageLocator(currentDirectory + \"/\");\n+        var packageDependencies = pnpapi.getPackageInformation(locator).packageDependencies;\n+        var typeRoots = [];\n+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {\n+            var _b = _a[_i], name = _b[0], referencish = _b[1];\n+            // eslint-disable-next-line no-null/no-null\n+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {\n+                var dependencyLocator = pnpapi.getLocator(name, referencish);\n+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;\n+                typeRoots.push(ts.getDirectoryPath(packageLocation));\n+            }\n+        }\n+        return typeRoots;\n+    }\n+    var typesPackagePrefix = \"@types/\";\n+    function getDefaultTypeRoots(currentDirectory, host) {\n+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);\n+        var pnpTypes = getPnpTypeRoots(currentDirectory);\n+        if (nmTypes.length > 0 || pnpTypes.length > 0) {\n+            return [].concat(nmTypes, pnpTypes);\n+        }\n+    }\n     /**\n      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n@@ -27883,7 +27909,9 @@ var ts;\n                 }\n                 var result = void 0;\n                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {\n-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n+                    var searchResult = isPnpAvailable()\n+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState)\n+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);\n                     result = searchResult && searchResult.value;\n                 }\n                 else {\n@@ -28367,9 +28395,12 @@ var ts;\n                 if (traceEnabled) {\n                     trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);\n                 }\n-                var resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n-                if (!resolved_1)\n+                var resolved_1 = isPnpAvailable()\n+                    ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state)\n+                    : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);\n+                if (!resolved_1) {\n                     return undefined;\n+                }\n                 var resolvedValue = resolved_1.value;\n                 if (!compilerOptions.preserveSymlinks && resolvedValue && !resolvedValue.originalPath) {\n                     var path = realPath(resolvedValue.path, host, traceEnabled);\n@@ -28865,6 +28896,57 @@ var ts;\n     function toSearchResult(value) {\n         return value !== undefined ? { value: value } : undefined;\n     }\n+    /**\n+     * We only allow PnP to be used as a resolution strategy if TypeScript\n+     * itself is executed under a PnP runtime (and we only allow it to access\n+     * the current PnP runtime, not any on the disk). This ensures that we\n+     * don't execute potentially malicious code that didn't already have a\n+     * chance to be executed (if we're running within the runtime, it means\n+     * that the runtime has already been executed).\n+     * @internal\n+     */\n+    function isPnpAvailable() {\n+        // @ts-ignore\n+        return process.versions.pnp;\n+    }\n+    function getPnpApi() {\n+        return require(\"pnpapi\");\n+    }\n+    function loadPnpPackageResolution(packageName, containingDirectory) {\n+        try {\n+            return getPnpApi().resolveToUnqualified(packageName, containingDirectory + \"/\", { considerBuiltins: false });\n+        }\n+        catch (_a) {\n+            // Nothing to do\n+        }\n+    }\n+    function loadPnpTypePackageResolution(packageName, containingDirectory) {\n+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);\n+    }\n+    /* @internal */\n+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state) {\n+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;\n+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);\n+        var packageFullResolution = packageResolution\n+            ? nodeLoadModuleByRelativeName(extensions, ts.combinePaths(packageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+            : undefined;\n+        var resolved;\n+        if (packageFullResolution) {\n+            resolved = packageFullResolution;\n+        }\n+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {\n+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);\n+            var typePackageFullResolution = typePackageResolution\n+                ? nodeLoadModuleByRelativeName(Extensions.DtsOnly, ts.combinePaths(typePackageResolution, rest), /*onlyRecordFailures*/ false, state, /*considerPackageJson*/ true)\n+                : undefined;\n+            if (typePackageFullResolution) {\n+                resolved = typePackageFullResolution;\n+            }\n+        }\n+        if (resolved) {\n+            return toSearchResult(resolved);\n+        }\n+    }\n })(ts || (ts = {}));\n /* @internal */\n var ts;\n"
;
