export const patch =
"diff --git a/fsevents.js b/fsevents.js\nsemver exclusivity ^1\n--- a/fsevents.js\n+++ b/fsevents.js\n@@ -36,11 +36,15 @@ module.exports.Constants = Native.Constants;\n var defer = global.setImmediate || process.nextTick;\n\n function watch(path) {\n-  var fse = new FSEvents(String(path || ''), handler);\n+  var VFS = require('./vfs');\n+  var vfs = new VFS(String(path || ''));\n+\n+  var fse = new FSEvents(vfs.resolvedPath, handler);\n   EventEmitter.call(fse);\n   return fse;\n\n   function handler(path, flags, id) {\n+    path = vfs.transpose(path);\n     defer(function() {\n       fse.emit('fsevent', path, flags, id);\n       var info = getInfo(path, flags);\ndiff --git a/fsevents.js b/fsevents.js\nsemver exclusivity ^2\n--- a/fsevents.js\n+++ b/fsevents.js\n@@ -21,5 +21,7 @@ function watch(path, handler) {\n     throw new TypeError(`fsevents argument 2 must be a function and not a ${typeof handler}`);\n   }\n\n-  let instance = Native.start(path, handler);\n+  let VFS = require('./vfs');\n+  let vfs = new VFS(path);\n+  let instance = Native.start(vfs.resolvedPath, vfs.wrap(handler));\n   if (!instance) throw new Error(`could not watch: ${path}`);\ndiff --git a/vfs.js b/vfs.js\nnew file mode 100644\n--- /dev/null\n+++ b/vfs.js\n@@ -0,0 +1,41 @@\n+const path = require(`path`);\n+\n+const NUMBER_REGEXP = /^[0-9]+$/;\n+const VIRTUAL_REGEXP = /^(\\/(?:[^\\/]+\\/)*?\\$\\$virtual)((?:\\/([^\\/]+)(?:\\/([^\\/]+))?)?((?:\\/.*)?))$/;\n+\n+function resolveVirtual(p) {\n+  const match = p.match(VIRTUAL_REGEXP);\n+  if (!match)\n+    return p;\n+\n+  const target = path.dirname(match[1]);\n+  if (!match[3] || !match[4])\n+    return target;\n+\n+  const isnum = NUMBER_REGEXP.test(match[4]);\n+  if (!isnum)\n+    return p;\n+\n+  const depth = Number(match[4]);\n+  const backstep = `../`.repeat(depth);\n+  const subpath = (match[5] || `.`);\n+\n+  return resolveVirtual(path.join(target, backstep, subpath));\n+}\n+\n+module.exports = class FsePnp {\n+  constructor(p) {\n+    this.normalizedPath = path.resolve(p);\n+    this.resolvedPath = resolveVirtual(this.normalizedPath);\n+  }\n+\n+  transpose(p) {\n+    return this.normalizedPath + p.substr(this.resolvedPath.length);\n+  }\n+\n+  wrap(fn) {\n+    return (path, ...args) => {\n+      return fn(this.transpose(path), ...args);\n+    };\n+  }\n+};\n"
;
