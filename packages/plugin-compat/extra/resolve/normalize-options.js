// Info: this file has been generated by Yarn in accordance with the approval
// of the `resolve` maintainers. Bugs caused by a code located here should be
// opened against the Yarn repository.

const path = require(`path`);

module.exports = function (_, opts) {
  opts = opts || {};

  if (opts.forceNodeResolution || !process.versions.pnp)
    return opts;

  // It would be nice if we could throw, but that would break the transparent
  // compatibility with packages that use `resolve` today (such as Gulp). Since
  // it's the whole point of this patch, we don't.
  //
  // if (opts.packageIterator || opts.paths)
  //   throw new Error(`The "packageIterator" and "paths" options cannot be used in PnP environments. Set "forceNodeResolution: true" if absolutely needed, or branch on process.versions.pnp otherwise.`);

  const pnp = require(`pnpapi`);

  const packageIterator = function (request, basedir, getCandidates, opts) {
    // Extract the name of the package being requested (1=full name, 2=scope name, 3=local name)
    const parts = request.match(/^((?:(@[^\/]+)\/)?([^\/]+))/);
    if (!parts)
      throw new Error(`Assertion failed: Expected the "resolve" package to call the "paths" callback with package names only (got "${request}")`);

    // Make sure that basedir ends with a slash
    if (basedir.charAt(basedir.length - 1) !== `/`)
      basedir = path.join(basedir, `/`);

    const api = pnp.findApiFromPath(basedir);
    if (api === null)
      return getCandidates();

    // This is guaranteed to return the path to the "package.json" file from the given package
    const manifestPath = api.resolveToUnqualified(`${parts[1]}/package.json`, basedir, {
      considerBuiltins: false,
    });

    if (manifestPath === null)
      throw new Error(`Assertion failed: The resolution thinks that "${parts[1]}" is a Node builtin`);

    // Strip the package.json to get the package folder
    return [path.dirname(manifestPath)];
  };

  const paths = function (request, basedir, opts) {
    return opts.packageIterator(request, basedir, () => [], opts).map(manifestPath => {
      // Stip the local named folder
      let nodeModules = path.dirname(manifestPath);

      // Strip the scope named folder if needed
      if (request.match(/^@[^\/]+\//))
        nodeModules = path.dirname(nodeModules);

      return nodeModules;
    });
  };

  // We need to keep track whether we're in `packageIterator` or not so that
  // the code is compatible with both `resolve` 1.9+ and `resolve` 1.15+
  let isInsideIterator = false;

  opts.packageIterator = function (request, basedir, getCandidates, opts) {
    isInsideIterator = true;
    try {
      return packageIterator(request, basedir, getCandidates, opts);
    } finally {
      isInsideIterator = false;
    }
  };

  opts.paths = function (request, basedir, getNodeModulePaths, opts) {
    if (isInsideIterator)
      return getNodeModulePaths();

    return paths(request, basedir, opts);
  };

  return opts;
};
