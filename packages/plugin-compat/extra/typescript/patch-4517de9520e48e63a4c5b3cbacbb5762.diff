diff --git a/lib/tsc.js b/lib/tsc.js
index c2c5c03f3..35d702868 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -4691,6 +4691,9 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                if (process.versions.pnp) {
+                    return true;
+                }
                 if (platform === "win32" || platform === "win64") {
                     return false;
                 }
@@ -35556,15 +35559,15 @@ var ts;
         }
     }
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -35575,6 +35578,37 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0;
     }
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     function resolveTypeReferenceDirective(typeReferenceDirectiveName, containingFile, options, host, redirectedReference, cache, resolutionMode) {
         ts.Debug.assert(typeof typeReferenceDirectiveName === "string", "Non-string value passed to `ts.resolveTypeReferenceDirective`, likely by a wrapping package working with an outdated `resolveTypeReferenceDirectives` signature. This is probably not a problem in TS itself.");
         var traceEnabled = isTraceEnabled(options, host);
@@ -35701,7 +35735,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, undefined, undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -36302,7 +36338,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -37151,8 +37189,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, undefined, undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, undefined, undefined, true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         if (!(state.features & NodeResolutionFeatures.Exports)) {
             if (packageInfo) {
@@ -37174,13 +37220,16 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -37352,6 +37401,50 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 var ts;
 (function (ts) {
@@ -97713,6 +97806,7 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["None"] = 0] = "None";
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     function updateSharedExtendedConfigFileWatcher(projectPath, options, extendedConfigFilesMap, createExtendedConfigFileWatch, toPath) {
         var _a;
@@ -104103,6 +104197,26 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -104139,14 +104253,18 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -104971,6 +105089,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         var getNewSourceFile = compilerHost.getSourceFile;
@@ -105049,6 +105171,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -105081,7 +105207,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -105091,7 +105218,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -105283,6 +105410,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -105298,6 +105431,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
diff --git a/lib/tsserver.js b/lib/tsserver.js
index fc48171a6..d973d7758 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -7303,6 +7303,11 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                // The PnP runtime is always case-sensitive
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    return true;
+                }
                 // win32\win64 are case insensitive platforms
                 if (platform === "win32" || platform === "win64") {
                     return false;
@@ -43474,18 +43479,17 @@ var ts;
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
     /**
      * Returns the path to every node_modules/@types directory from some ancestor directory.
-     * Returns undefined if there are none.
      */
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
             // And if it doesn't exist, tough.
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -43496,6 +43500,42 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* Comparison.EqualTo */;
     }
+    /**
+     * @internal
+     */
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        // Some TS consumers pass relative paths that aren't normalized
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            // eslint-disable-next-line no-null/no-null
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
@@ -43637,7 +43677,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -44365,7 +44407,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -45320,8 +45364,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, /* rest */ undefined, /* packageDirectory */ undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, /*moduleName*/ undefined, /*nodeModulesDirectory*/ undefined, /*nodeModulesDirectoryExists*/ true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         // But only if we're not respecting export maps (if we are, we might redirect around this location)
@@ -45348,15 +45400,18 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -45550,6 +45605,61 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    /**
+     * We only allow PnP to be used as a resolution strategy if TypeScript
+     * itself is executed under a PnP runtime (and we only allow it to access
+     * the current PnP runtime, not any on the disk). This ensures that we
+     * don't execute potentially malicious code that didn't already have a
+     * chance to be executed (if we're running within the runtime, it means
+     * that the runtime has already been executed).
+     * @internal
+     */
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+            // Nothing to do
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    /* @internal */
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 /* @internal */
 var ts;
@@ -118138,6 +118248,8 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         /** Reload completely by re-reading contents of config file from disk and updating program */
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        /** Reload the resolutions */
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     /**
      * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
@@ -125541,6 +125653,30 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                // eslint-disable-next-line no-null/no-null
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    // Don't use the package name when the imported file is inside
+                    // the source directory (prefer a relative path instead)
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        // The last character from packageLocation is the trailing "/", we want to point to it
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -125580,18 +125716,24 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            // Get a path that's relative to node_modules or the importing file's path
-            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they
+            // are located in a weird path apparently outside of the source directory
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                // Get a path that's relative to node_modules or the importing file's path
+                // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
             // If the module was found in @types, get the actual Node package name
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
             // For classic resolution, only allow importing from node_modules/@types, not other node_modules
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -126484,6 +126626,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         // Members for CompilerHost
@@ -126570,6 +126716,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -126602,7 +126752,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -126612,7 +126763,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -126826,6 +126977,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -126841,6 +126998,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(/*forceAllFilesAsInvalidated*/ true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
@@ -132818,7 +132979,7 @@ var ts;
      * Don't include something from a `node_modules` that isn't actually reachable by a global import.
      * A relative import to node_modules is usually a bad idea.
      */
-    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+    function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {
         // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
         var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
         var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
@@ -132826,6 +132987,36 @@ var ts;
             || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
             || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
     }
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function isImportablePathPnp(fromPath, toPath) {
+        var pnpApi = getPnpApi(fromPath);
+        var fromLocator = pnpApi.findPackageLocator(fromPath);
+        var toLocator = pnpApi.findPackageLocator(toPath);
+        // eslint-disable-next-line no-null/no-null
+        if (toLocator === null) {
+            return false;
+        }
+        var fromInfo = pnpApi.getPackageInformation(fromLocator);
+        var toReference = fromInfo.packageDependencies.get(toLocator.name);
+        return toReference === toLocator.reference;
+    }
+    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+        if (getPnpApi(fromPath)) {
+            return isImportablePathPnp(fromPath, toPath);
+        }
+        else {
+            return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);
+        }
+    }
     function forEachExternalModuleToImportFrom(program, host, preferences, useAutoImportProvider, cb) {
         var _a, _b;
         var useCaseSensitiveFileNames = ts.hostUsesCaseSensitiveFileNames(host);
@@ -134737,6 +134928,7 @@ var ts;
              *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
              */
             function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, compilerOptions, host, includeExtensionsOption, typeChecker) {
+                var _a, _b;
                 var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                 var result = createNameAndKindSet();
                 var extensionOptions = getExtensionOptions(compilerOptions, includeExtensionsOption);
@@ -134749,8 +134941,8 @@ var ts;
                     }
                 }
                 var fragmentDirectory = getFragmentDirectory(fragment);
-                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
-                    var ambientName = _a[_i];
+                for (var _i = 0, _c = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _c.length; _i++) {
+                    var ambientName = _c[_i];
                     result.add(nameAndKind(ambientName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                 }
                 getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
@@ -134759,8 +134951,8 @@ var ts;
                     // (But do if we didn't find anything, e.g. 'package.json' missing.)
                     var foundGlobal = false;
                     if (fragmentDirectory === undefined) {
-                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
-                            var moduleName = _c[_b];
+                        for (var _d = 0, _e = enumerateNodeModulesVisibleToScript(host, scriptPath); _d < _e.length; _d++) {
+                            var moduleName = _e[_d];
                             var moduleResult = nameAndKind(moduleName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined);
                             if (!result.has(moduleResult.name)) {
                                 foundGlobal = true;
@@ -134775,7 +134967,22 @@ var ts;
                                 getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                             }
                         };
-                        if (fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions)) {
+                        var checkExports_1 = function (packageFile, packageDirectory, fragmentSubpath) {
+                            var packageJson = ts.readJson(packageFile, host);
+                            var exports = packageJson.exports;
+                            if (exports) {
+                                if (typeof exports !== "object" || exports === null) { // eslint-disable-line no-null/no-null
+                                    return true; // null exports or entrypoint only, no sub-modules available
+                                }
+                                var keys = ts.getOwnKeys(exports);
+                                var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
+                                addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions_1)); }, ts.comparePatternKeys);
+                                return true;
+                            }
+                            return false;
+                        };
+                        var shouldCheckExports = fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions);
+                        if (shouldCheckExports) {
                             var nodeModulesDirectoryLookup_1 = ancestorLookup;
                             ancestorLookup = function (ancestor) {
                                 var components = ts.getPathComponents(fragment);
@@ -134794,23 +135001,46 @@ var ts;
                                 var packageDirectory = ts.combinePaths(ancestor, "node_modules", packagePath);
                                 var packageFile = ts.combinePaths(packageDirectory, "package.json");
                                 if (ts.tryFileExists(host, packageFile)) {
-                                    var packageJson = ts.readJson(packageFile, host);
-                                    var exports_1 = packageJson.exports;
-                                    if (exports_1) {
-                                        if (typeof exports_1 !== "object" || exports_1 === null) { // eslint-disable-line no-null/no-null
-                                            return; // null exports or entrypoint only, no sub-modules available
-                                        }
-                                        var keys = ts.getOwnKeys(exports_1);
-                                        var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                                        var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
-                                        addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports_1[key], conditions_1)); }, ts.comparePatternKeys);
+                                    var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
+                                    if (checkExports_1(packageFile, packageDirectory, fragmentSubpath)) {
                                         return;
                                     }
                                 }
                                 return nodeModulesDirectoryLookup_1(ancestor);
                             };
                         }
-                        ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        var pnpapi = typeof process.versions.pnp === "undefined" ? undefined : (_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath);
+                        if (pnpapi) {
+                            // Splits a require request into its components, or return null if the request is a file path
+                            var pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+                            var dependencyNameMatch = fragment.match(pathRegExp);
+                            if (dependencyNameMatch) {
+                                var dependencyName = dependencyNameMatch[1], subPath = dependencyNameMatch[2];
+                                var unqualified = void 0;
+                                try {
+                                    unqualified = pnpapi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+                                }
+                                catch (_f) {
+                                    // It's fine if the resolution fails
+                                }
+                                if (unqualified) {
+                                    var packageDirectory = ts.normalizePath(unqualified);
+                                    var shouldGetCompletions = true;
+                                    if (shouldCheckExports) {
+                                        var packageFile = ts.combinePaths(packageDirectory, "package.json");
+                                        if (ts.tryFileExists(host, packageFile) && checkExports_1(packageFile, packageDirectory, subPath)) {
+                                            shouldGetCompletions = false;
+                                        }
+                                    }
+                                    if (shouldGetCompletions) {
+                                        getCompletionEntriesForDirectoryFragment(subPath, packageDirectory, extensionOptions, host, /*exclude*/ undefined, result);
+                                    }
+                                }
+                            }
+                        }
+                        else {
+                            ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        }
                     }
                 }
                 return ts.arrayFrom(result.values());
@@ -134941,6 +135171,7 @@ var ts;
                 return addReplacementSpans(toComplete, range.pos + prefix.length, ts.arrayFrom(names.values()));
             }
             function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
+                var _a, _b;
                 if (result === void 0) { result = createNameAndKindSet(); }
                 // Check for typings specified in compiler options
                 var seen = new ts.Map();
@@ -134949,11 +135180,19 @@ var ts;
                     var root = typeRoots_1[_i];
                     getCompletionEntriesFromDirectories(root);
                 }
-                // Also get all @types typings installed in visible node_modules directories
-                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
-                    var packageJson = _b[_a];
-                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
-                    getCompletionEntriesFromDirectories(typesDir);
+                if (typeof process.versions.pnp !== "undefined" && ((_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath))) {
+                    for (var _c = 0, _d = ts.getPnpTypeRoots(scriptPath); _c < _d.length; _c++) {
+                        var root = _d[_c];
+                        getCompletionEntriesFromDirectories(root);
+                    }
+                }
+                else {
+                    // Also get all @types typings installed in visible node_modules directories
+                    for (var _e = 0, _f = ts.findPackageJsons(scriptPath, host); _e < _f.length; _e++) {
+                        var packageJson = _f[_e];
+                        var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
+                        getCompletionEntriesFromDirectories(typesDir);
+                    }
                 }
                 return result;
                 function getCompletionEntriesFromDirectories(directory) {
@@ -166117,9 +166356,9 @@ var ts;
                 if (isTopLevelDeclarationStatement(statement) &&
                     !isExported(sourceFile, statement, useEs6Exports) &&
                     forEachTopLevelDeclaration(statement, function (d) { return needExport.has(ts.Debug.checkDefined(d.symbol)); })) {
-                    var exports = addExport(statement, useEs6Exports);
-                    if (exports)
-                        return exports;
+                    var exports_1 = addExport(statement, useEs6Exports);
+                    if (exports_1)
+                        return exports_1;
                 }
                 return statement;
             });
@@ -175305,6 +175544,40 @@ var ts;
                 return this.projectReferences;
             };
             ConfiguredProject.prototype.updateReferences = function (refs) {
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    // With Plug'n'Play, dependencies that list peer dependencies
+                    // are "virtualized": they are resolved to a unique (virtual)
+                    // path that the underlying filesystem layer then resolve back
+                    // to the original location.
+                    //
+                    // When a workspace depends on another workspace with peer
+                    // dependencies, this other workspace will thus be resolved to
+                    // a unique path that won't match what the initial project has
+                    // listed in its `references` field, and TS thus won't leverage
+                    // the reference at all.
+                    //
+                    // To avoid that, we compute here the virtualized paths for the
+                    // user-provided references in our references by directly querying
+                    // the PnP API. This way users don't have to know the virtual paths,
+                    // but we still support them just fine even through references.
+                    var basePath_1 = this.getCurrentDirectory();
+                    var findPnpApi_1 = require("module").findPnpApi;
+                    var getPnpPath_1 = function (path) {
+                        try {
+                            var pnpApi = findPnpApi_1("".concat(path, "/"));
+                            var targetLocator = pnpApi.findPackageLocator("".concat(path, "/"));
+                            var packageLocation = pnpApi.getPackageInformation(targetLocator).packageLocation;
+                            var request = ts.combinePaths(targetLocator.name, ts.getRelativePathFromDirectory(packageLocation, path, /*ignoreCase*/ false));
+                            return pnpApi.resolveToUnqualified(request, "".concat(basePath_1, "/"));
+                        }
+                        catch (_a) {
+                            // something went wrong with the resolution, try not to fail
+                            return path;
+                        }
+                    };
+                    refs = refs === null || refs === void 0 ? void 0 : refs.map(function (r) { return (__assign(__assign({}, r), { path: getPnpPath_1(r.path) })); });
+                }
                 this.projectReferences = refs;
                 this.potentialProjectReferences = undefined;
             };
@@ -175925,6 +176198,7 @@ var ts;
                         watchDirectory: ts.returnNoopFileWatcher,
                     } :
                     ts.getWatchFactory(this.host, watchLogLevel, log, getDetailWatchInfo);
+                this.pnpWatcher = this.watchPnpFile();
             }
             ProjectService.prototype.toPath = function (fileName) {
                 return ts.toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
@@ -177784,7 +178058,7 @@ var ts;
             };
             ProjectService.prototype.setHostConfiguration = function (args) {
                 var _this = this;
-                var _a;
+                var _a, _b;
                 if (args.file) {
                     var info = this.getScriptInfoForNormalizedPath(server.toNormalizedPath(args.file));
                     if (info) {
@@ -177802,7 +178076,7 @@ var ts;
                         this.logger.info("Format host information updated");
                     }
                     if (args.preferences) {
-                        var _b = this.hostConfiguration.preferences, lazyConfiguredProjectsFromExternalProject = _b.lazyConfiguredProjectsFromExternalProject, includePackageJsonAutoImports = _b.includePackageJsonAutoImports;
+                        var _c = this.hostConfiguration.preferences, lazyConfiguredProjectsFromExternalProject = _c.lazyConfiguredProjectsFromExternalProject, includePackageJsonAutoImports = _c.includePackageJsonAutoImports;
                         this.hostConfiguration.preferences = __assign(__assign({}, this.hostConfiguration.preferences), args.preferences);
                         if (lazyConfiguredProjectsFromExternalProject && !this.hostConfiguration.preferences.lazyConfiguredProjectsFromExternalProject) {
                             // Load configured projects for external projects that are pending reload
@@ -177828,6 +178102,8 @@ var ts;
                     if (args.watchOptions) {
                         this.hostConfiguration.watchOptions = (_a = convertWatchOptions(args.watchOptions)) === null || _a === void 0 ? void 0 : _a.watchOptions;
                         this.logger.info("Host watch options changed to ".concat(JSON.stringify(this.hostConfiguration.watchOptions), ", it will be take effect for next watches."));
+                        (_b = this.pnpWatcher) === null || _b === void 0 ? void 0 : _b.close();
+                        this.watchPnpFile();
                     }
                 }
             };
@@ -178963,6 +179239,29 @@ var ts;
                 });
             };
             /*@internal*/
+            ProjectService.prototype.watchPnpFile = function () {
+                var _this = this;
+                if (typeof process.versions.pnp === "undefined") {
+                    return;
+                }
+                var pnpApi = require("module").findPnpApi(__filename);
+                if (!pnpApi) {
+                    return;
+                }
+                var pnpFileName = pnpApi.resolveRequest("pnpapi", /*issuer*/ null);
+                return this.watchFactory.watchFile(pnpFileName, function () {
+                    _this.forEachProject(function (project) {
+                        for (var _i = 0, _a = project.getScriptInfos(); _i < _a.length; _i++) {
+                            var info = _a[_i];
+                            project.resolutionCache.invalidateResolutionOfFile(info.path);
+                        }
+                        project.markAsDirty();
+                        updateProjectIfDirty(project);
+                    });
+                    _this.delayEnsureProjectForOpenFiles();
+                }, ts.PollingInterval.Low, this.hostConfiguration.watchOptions, ts.WatchType.ConfigFile);
+            };
+            /*@internal*/
             ProjectService.prototype.watchPackageJsonFile = function (path) {
                 var _this = this;
                 var watchers = this.packageJsonFilesMap || (this.packageJsonFilesMap = new ts.Map());
@@ -185706,6 +186005,12 @@ var ts;
                         }
                         try {
                             var args = [ts.combinePaths(__dirname, "watchGuard.js"), path];
+                            if (typeof process.versions.pnp !== "undefined") {
+                                var pnpApi = require("module").findPnpApi(__filename);
+                                if (pnpApi) {
+                                    args.unshift('-r', pnpApi.resolveRequest("pnpapi", /* issuer */ null));
+                                }
+                            }
                             if (logger.hasLevel(server.LogLevel.verbose)) {
                                 logger.info("Starting ".concat(process.execPath, " with args:").concat(server.stringifyIndented(args)));
                             }
@@ -185952,6 +186257,12 @@ var ts;
                             break;
                         }
                     }
+                    if (typeof process.versions.pnp !== "undefined") {
+                        var pnpApi = require("module").findPnpApi(__filename);
+                        if (pnpApi) {
+                            execArgv.unshift('-r', pnpApi.resolveRequest("pnpapi", /* issuer */ null));
+                        }
+                    }
                     this.installer = childProcess.fork(ts.combinePaths(__dirname, "typingsInstaller.js"), args, { execArgv: execArgv });
                     this.installer.on("message", function (m) { return _this.handleMessage(m); });
                     // We have to schedule this event to the next tick
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index ec521e9cc..b4512e1b8 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -7302,6 +7302,11 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                // The PnP runtime is always case-sensitive
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    return true;
+                }
                 // win32\win64 are case insensitive platforms
                 if (platform === "win32" || platform === "win64") {
                     return false;
@@ -43473,18 +43478,17 @@ var ts;
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
     /**
      * Returns the path to every node_modules/@types directory from some ancestor directory.
-     * Returns undefined if there are none.
      */
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
             // And if it doesn't exist, tough.
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -43495,6 +43499,42 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* Comparison.EqualTo */;
     }
+    /**
+     * @internal
+     */
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        // Some TS consumers pass relative paths that aren't normalized
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            // eslint-disable-next-line no-null/no-null
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
@@ -43636,7 +43676,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -44364,7 +44406,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -45319,8 +45363,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, /* rest */ undefined, /* packageDirectory */ undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, /*moduleName*/ undefined, /*nodeModulesDirectory*/ undefined, /*nodeModulesDirectoryExists*/ true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         // But only if we're not respecting export maps (if we are, we might redirect around this location)
@@ -45347,15 +45399,18 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -45549,6 +45604,61 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    /**
+     * We only allow PnP to be used as a resolution strategy if TypeScript
+     * itself is executed under a PnP runtime (and we only allow it to access
+     * the current PnP runtime, not any on the disk). This ensures that we
+     * don't execute potentially malicious code that didn't already have a
+     * chance to be executed (if we're running within the runtime, it means
+     * that the runtime has already been executed).
+     * @internal
+     */
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+            // Nothing to do
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    /* @internal */
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 /* @internal */
 var ts;
@@ -118137,6 +118247,8 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         /** Reload completely by re-reading contents of config file from disk and updating program */
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        /** Reload the resolutions */
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     /**
      * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
@@ -125540,6 +125652,30 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                // eslint-disable-next-line no-null/no-null
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    // Don't use the package name when the imported file is inside
+                    // the source directory (prefer a relative path instead)
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        // The last character from packageLocation is the trailing "/", we want to point to it
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -125579,18 +125715,24 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            // Get a path that's relative to node_modules or the importing file's path
-            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they
+            // are located in a weird path apparently outside of the source directory
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                // Get a path that's relative to node_modules or the importing file's path
+                // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
             // If the module was found in @types, get the actual Node package name
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
             // For classic resolution, only allow importing from node_modules/@types, not other node_modules
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -126483,6 +126625,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         // Members for CompilerHost
@@ -126569,6 +126715,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -126601,7 +126751,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -126611,7 +126762,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -126825,6 +126976,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -126840,6 +126997,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(/*forceAllFilesAsInvalidated*/ true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
@@ -133236,7 +133397,7 @@ var ts;
      * Don't include something from a `node_modules` that isn't actually reachable by a global import.
      * A relative import to node_modules is usually a bad idea.
      */
-    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+    function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {
         // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
         var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
         var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
@@ -133244,6 +133405,36 @@ var ts;
             || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
             || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
     }
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function isImportablePathPnp(fromPath, toPath) {
+        var pnpApi = getPnpApi(fromPath);
+        var fromLocator = pnpApi.findPackageLocator(fromPath);
+        var toLocator = pnpApi.findPackageLocator(toPath);
+        // eslint-disable-next-line no-null/no-null
+        if (toLocator === null) {
+            return false;
+        }
+        var fromInfo = pnpApi.getPackageInformation(fromLocator);
+        var toReference = fromInfo.packageDependencies.get(toLocator.name);
+        return toReference === toLocator.reference;
+    }
+    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+        if (getPnpApi(fromPath)) {
+            return isImportablePathPnp(fromPath, toPath);
+        }
+        else {
+            return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);
+        }
+    }
     function forEachExternalModuleToImportFrom(program, host, preferences, useAutoImportProvider, cb) {
         var _a, _b;
         var useCaseSensitiveFileNames = ts.hostUsesCaseSensitiveFileNames(host);
@@ -135155,6 +135346,7 @@ var ts;
              *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
              */
             function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, compilerOptions, host, includeExtensionsOption, typeChecker) {
+                var _a, _b;
                 var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                 var result = createNameAndKindSet();
                 var extensionOptions = getExtensionOptions(compilerOptions, includeExtensionsOption);
@@ -135167,8 +135359,8 @@ var ts;
                     }
                 }
                 var fragmentDirectory = getFragmentDirectory(fragment);
-                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
-                    var ambientName = _a[_i];
+                for (var _i = 0, _c = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _c.length; _i++) {
+                    var ambientName = _c[_i];
                     result.add(nameAndKind(ambientName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                 }
                 getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
@@ -135177,8 +135369,8 @@ var ts;
                     // (But do if we didn't find anything, e.g. 'package.json' missing.)
                     var foundGlobal = false;
                     if (fragmentDirectory === undefined) {
-                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
-                            var moduleName = _c[_b];
+                        for (var _d = 0, _e = enumerateNodeModulesVisibleToScript(host, scriptPath); _d < _e.length; _d++) {
+                            var moduleName = _e[_d];
                             var moduleResult = nameAndKind(moduleName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined);
                             if (!result.has(moduleResult.name)) {
                                 foundGlobal = true;
@@ -135193,7 +135385,22 @@ var ts;
                                 getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                             }
                         };
-                        if (fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions)) {
+                        var checkExports_1 = function (packageFile, packageDirectory, fragmentSubpath) {
+                            var packageJson = ts.readJson(packageFile, host);
+                            var exports = packageJson.exports;
+                            if (exports) {
+                                if (typeof exports !== "object" || exports === null) { // eslint-disable-line no-null/no-null
+                                    return true; // null exports or entrypoint only, no sub-modules available
+                                }
+                                var keys = ts.getOwnKeys(exports);
+                                var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
+                                addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions_1)); }, ts.comparePatternKeys);
+                                return true;
+                            }
+                            return false;
+                        };
+                        var shouldCheckExports = fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions);
+                        if (shouldCheckExports) {
                             var nodeModulesDirectoryLookup_1 = ancestorLookup;
                             ancestorLookup = function (ancestor) {
                                 var components = ts.getPathComponents(fragment);
@@ -135212,23 +135419,46 @@ var ts;
                                 var packageDirectory = ts.combinePaths(ancestor, "node_modules", packagePath);
                                 var packageFile = ts.combinePaths(packageDirectory, "package.json");
                                 if (ts.tryFileExists(host, packageFile)) {
-                                    var packageJson = ts.readJson(packageFile, host);
-                                    var exports_1 = packageJson.exports;
-                                    if (exports_1) {
-                                        if (typeof exports_1 !== "object" || exports_1 === null) { // eslint-disable-line no-null/no-null
-                                            return; // null exports or entrypoint only, no sub-modules available
-                                        }
-                                        var keys = ts.getOwnKeys(exports_1);
-                                        var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                                        var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
-                                        addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports_1[key], conditions_1)); }, ts.comparePatternKeys);
+                                    var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
+                                    if (checkExports_1(packageFile, packageDirectory, fragmentSubpath)) {
                                         return;
                                     }
                                 }
                                 return nodeModulesDirectoryLookup_1(ancestor);
                             };
                         }
-                        ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        var pnpapi = typeof process.versions.pnp === "undefined" ? undefined : (_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath);
+                        if (pnpapi) {
+                            // Splits a require request into its components, or return null if the request is a file path
+                            var pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+                            var dependencyNameMatch = fragment.match(pathRegExp);
+                            if (dependencyNameMatch) {
+                                var dependencyName = dependencyNameMatch[1], subPath = dependencyNameMatch[2];
+                                var unqualified = void 0;
+                                try {
+                                    unqualified = pnpapi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+                                }
+                                catch (_f) {
+                                    // It's fine if the resolution fails
+                                }
+                                if (unqualified) {
+                                    var packageDirectory = ts.normalizePath(unqualified);
+                                    var shouldGetCompletions = true;
+                                    if (shouldCheckExports) {
+                                        var packageFile = ts.combinePaths(packageDirectory, "package.json");
+                                        if (ts.tryFileExists(host, packageFile) && checkExports_1(packageFile, packageDirectory, subPath)) {
+                                            shouldGetCompletions = false;
+                                        }
+                                    }
+                                    if (shouldGetCompletions) {
+                                        getCompletionEntriesForDirectoryFragment(subPath, packageDirectory, extensionOptions, host, /*exclude*/ undefined, result);
+                                    }
+                                }
+                            }
+                        }
+                        else {
+                            ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        }
                     }
                 }
                 return ts.arrayFrom(result.values());
@@ -135359,6 +135589,7 @@ var ts;
                 return addReplacementSpans(toComplete, range.pos + prefix.length, ts.arrayFrom(names.values()));
             }
             function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
+                var _a, _b;
                 if (result === void 0) { result = createNameAndKindSet(); }
                 // Check for typings specified in compiler options
                 var seen = new ts.Map();
@@ -135367,11 +135598,19 @@ var ts;
                     var root = typeRoots_1[_i];
                     getCompletionEntriesFromDirectories(root);
                 }
-                // Also get all @types typings installed in visible node_modules directories
-                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
-                    var packageJson = _b[_a];
-                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
-                    getCompletionEntriesFromDirectories(typesDir);
+                if (typeof process.versions.pnp !== "undefined" && ((_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath))) {
+                    for (var _c = 0, _d = ts.getPnpTypeRoots(scriptPath); _c < _d.length; _c++) {
+                        var root = _d[_c];
+                        getCompletionEntriesFromDirectories(root);
+                    }
+                }
+                else {
+                    // Also get all @types typings installed in visible node_modules directories
+                    for (var _e = 0, _f = ts.findPackageJsons(scriptPath, host); _e < _f.length; _e++) {
+                        var packageJson = _f[_e];
+                        var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
+                        getCompletionEntriesFromDirectories(typesDir);
+                    }
                 }
                 return result;
                 function getCompletionEntriesFromDirectories(directory) {
@@ -166535,9 +166774,9 @@ var ts;
                 if (isTopLevelDeclarationStatement(statement) &&
                     !isExported(sourceFile, statement, useEs6Exports) &&
                     forEachTopLevelDeclaration(statement, function (d) { return needExport.has(ts.Debug.checkDefined(d.symbol)); })) {
-                    var exports = addExport(statement, useEs6Exports);
-                    if (exports)
-                        return exports;
+                    var exports_1 = addExport(statement, useEs6Exports);
+                    if (exports_1)
+                        return exports_1;
                 }
                 return statement;
             });
@@ -175304,6 +175543,40 @@ var ts;
                 return this.projectReferences;
             };
             ConfiguredProject.prototype.updateReferences = function (refs) {
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    // With Plug'n'Play, dependencies that list peer dependencies
+                    // are "virtualized": they are resolved to a unique (virtual)
+                    // path that the underlying filesystem layer then resolve back
+                    // to the original location.
+                    //
+                    // When a workspace depends on another workspace with peer
+                    // dependencies, this other workspace will thus be resolved to
+                    // a unique path that won't match what the initial project has
+                    // listed in its `references` field, and TS thus won't leverage
+                    // the reference at all.
+                    //
+                    // To avoid that, we compute here the virtualized paths for the
+                    // user-provided references in our references by directly querying
+                    // the PnP API. This way users don't have to know the virtual paths,
+                    // but we still support them just fine even through references.
+                    var basePath_1 = this.getCurrentDirectory();
+                    var findPnpApi_1 = require("module").findPnpApi;
+                    var getPnpPath_1 = function (path) {
+                        try {
+                            var pnpApi = findPnpApi_1("".concat(path, "/"));
+                            var targetLocator = pnpApi.findPackageLocator("".concat(path, "/"));
+                            var packageLocation = pnpApi.getPackageInformation(targetLocator).packageLocation;
+                            var request = ts.combinePaths(targetLocator.name, ts.getRelativePathFromDirectory(packageLocation, path, /*ignoreCase*/ false));
+                            return pnpApi.resolveToUnqualified(request, "".concat(basePath_1, "/"));
+                        }
+                        catch (_a) {
+                            // something went wrong with the resolution, try not to fail
+                            return path;
+                        }
+                    };
+                    refs = refs === null || refs === void 0 ? void 0 : refs.map(function (r) { return (__assign(__assign({}, r), { path: getPnpPath_1(r.path) })); });
+                }
                 this.projectReferences = refs;
                 this.potentialProjectReferences = undefined;
             };
@@ -175924,6 +176197,7 @@ var ts;
                         watchDirectory: ts.returnNoopFileWatcher,
                     } :
                     ts.getWatchFactory(this.host, watchLogLevel, log, getDetailWatchInfo);
+                this.pnpWatcher = this.watchPnpFile();
             }
             ProjectService.prototype.toPath = function (fileName) {
                 return ts.toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
@@ -177783,7 +178057,7 @@ var ts;
             };
             ProjectService.prototype.setHostConfiguration = function (args) {
                 var _this = this;
-                var _a;
+                var _a, _b;
                 if (args.file) {
                     var info = this.getScriptInfoForNormalizedPath(server.toNormalizedPath(args.file));
                     if (info) {
@@ -177801,7 +178075,7 @@ var ts;
                         this.logger.info("Format host information updated");
                     }
                     if (args.preferences) {
-                        var _b = this.hostConfiguration.preferences, lazyConfiguredProjectsFromExternalProject = _b.lazyConfiguredProjectsFromExternalProject, includePackageJsonAutoImports = _b.includePackageJsonAutoImports;
+                        var _c = this.hostConfiguration.preferences, lazyConfiguredProjectsFromExternalProject = _c.lazyConfiguredProjectsFromExternalProject, includePackageJsonAutoImports = _c.includePackageJsonAutoImports;
                         this.hostConfiguration.preferences = __assign(__assign({}, this.hostConfiguration.preferences), args.preferences);
                         if (lazyConfiguredProjectsFromExternalProject && !this.hostConfiguration.preferences.lazyConfiguredProjectsFromExternalProject) {
                             // Load configured projects for external projects that are pending reload
@@ -177827,6 +178101,8 @@ var ts;
                     if (args.watchOptions) {
                         this.hostConfiguration.watchOptions = (_a = convertWatchOptions(args.watchOptions)) === null || _a === void 0 ? void 0 : _a.watchOptions;
                         this.logger.info("Host watch options changed to ".concat(JSON.stringify(this.hostConfiguration.watchOptions), ", it will be take effect for next watches."));
+                        (_b = this.pnpWatcher) === null || _b === void 0 ? void 0 : _b.close();
+                        this.watchPnpFile();
                     }
                 }
             };
@@ -178962,6 +179238,29 @@ var ts;
                 });
             };
             /*@internal*/
+            ProjectService.prototype.watchPnpFile = function () {
+                var _this = this;
+                if (typeof process.versions.pnp === "undefined") {
+                    return;
+                }
+                var pnpApi = require("module").findPnpApi(__filename);
+                if (!pnpApi) {
+                    return;
+                }
+                var pnpFileName = pnpApi.resolveRequest("pnpapi", /*issuer*/ null);
+                return this.watchFactory.watchFile(pnpFileName, function () {
+                    _this.forEachProject(function (project) {
+                        for (var _i = 0, _a = project.getScriptInfos(); _i < _a.length; _i++) {
+                            var info = _a[_i];
+                            project.resolutionCache.invalidateResolutionOfFile(info.path);
+                        }
+                        project.markAsDirty();
+                        updateProjectIfDirty(project);
+                    });
+                    _this.delayEnsureProjectForOpenFiles();
+                }, ts.PollingInterval.Low, this.hostConfiguration.watchOptions, ts.WatchType.ConfigFile);
+            };
+            /*@internal*/
             ProjectService.prototype.watchPackageJsonFile = function (path) {
                 var _this = this;
                 var watchers = this.packageJsonFilesMap || (this.packageJsonFilesMap = new ts.Map());
diff --git a/lib/typescript.js b/lib/typescript.js
index 530b87683..62a2b6fa0 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -7293,6 +7293,11 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                // The PnP runtime is always case-sensitive
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    return true;
+                }
                 // win32\win64 are case insensitive platforms
                 if (platform === "win32" || platform === "win64") {
                     return false;
@@ -43464,18 +43469,17 @@ var ts;
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
     /**
      * Returns the path to every node_modules/@types directory from some ancestor directory.
-     * Returns undefined if there are none.
      */
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
             // And if it doesn't exist, tough.
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -43486,6 +43490,42 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* Comparison.EqualTo */;
     }
+    /**
+     * @internal
+     */
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        // Some TS consumers pass relative paths that aren't normalized
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            // eslint-disable-next-line no-null/no-null
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
@@ -43627,7 +43667,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -44355,7 +44397,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -45310,8 +45354,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, /* rest */ undefined, /* packageDirectory */ undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, /*moduleName*/ undefined, /*nodeModulesDirectory*/ undefined, /*nodeModulesDirectoryExists*/ true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         // But only if we're not respecting export maps (if we are, we might redirect around this location)
@@ -45338,15 +45390,18 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -45540,6 +45595,61 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    /**
+     * We only allow PnP to be used as a resolution strategy if TypeScript
+     * itself is executed under a PnP runtime (and we only allow it to access
+     * the current PnP runtime, not any on the disk). This ensures that we
+     * don't execute potentially malicious code that didn't already have a
+     * chance to be executed (if we're running within the runtime, it means
+     * that the runtime has already been executed).
+     * @internal
+     */
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+            // Nothing to do
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    /* @internal */
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 /* @internal */
 var ts;
@@ -118128,6 +118238,8 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         /** Reload completely by re-reading contents of config file from disk and updating program */
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        /** Reload the resolutions */
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     /**
      * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
@@ -125531,6 +125643,30 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                // eslint-disable-next-line no-null/no-null
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    // Don't use the package name when the imported file is inside
+                    // the source directory (prefer a relative path instead)
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        // The last character from packageLocation is the trailing "/", we want to point to it
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -125570,18 +125706,24 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            // Get a path that's relative to node_modules or the importing file's path
-            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they
+            // are located in a weird path apparently outside of the source directory
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                // Get a path that's relative to node_modules or the importing file's path
+                // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
             // If the module was found in @types, get the actual Node package name
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
             // For classic resolution, only allow importing from node_modules/@types, not other node_modules
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -126474,6 +126616,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         // Members for CompilerHost
@@ -126560,6 +126706,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -126592,7 +126742,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -126602,7 +126753,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -126816,6 +126967,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -126831,6 +126988,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(/*forceAllFilesAsInvalidated*/ true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
@@ -133227,7 +133388,7 @@ var ts;
      * Don't include something from a `node_modules` that isn't actually reachable by a global import.
      * A relative import to node_modules is usually a bad idea.
      */
-    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+    function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {
         // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
         var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
         var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
@@ -133235,6 +133396,36 @@ var ts;
             || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
             || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
     }
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function isImportablePathPnp(fromPath, toPath) {
+        var pnpApi = getPnpApi(fromPath);
+        var fromLocator = pnpApi.findPackageLocator(fromPath);
+        var toLocator = pnpApi.findPackageLocator(toPath);
+        // eslint-disable-next-line no-null/no-null
+        if (toLocator === null) {
+            return false;
+        }
+        var fromInfo = pnpApi.getPackageInformation(fromLocator);
+        var toReference = fromInfo.packageDependencies.get(toLocator.name);
+        return toReference === toLocator.reference;
+    }
+    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+        if (getPnpApi(fromPath)) {
+            return isImportablePathPnp(fromPath, toPath);
+        }
+        else {
+            return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);
+        }
+    }
     function forEachExternalModuleToImportFrom(program, host, preferences, useAutoImportProvider, cb) {
         var _a, _b;
         var useCaseSensitiveFileNames = ts.hostUsesCaseSensitiveFileNames(host);
@@ -135146,6 +135337,7 @@ var ts;
              *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
              */
             function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, compilerOptions, host, includeExtensionsOption, typeChecker) {
+                var _a, _b;
                 var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                 var result = createNameAndKindSet();
                 var extensionOptions = getExtensionOptions(compilerOptions, includeExtensionsOption);
@@ -135158,8 +135350,8 @@ var ts;
                     }
                 }
                 var fragmentDirectory = getFragmentDirectory(fragment);
-                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
-                    var ambientName = _a[_i];
+                for (var _i = 0, _c = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _c.length; _i++) {
+                    var ambientName = _c[_i];
                     result.add(nameAndKind(ambientName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                 }
                 getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
@@ -135168,8 +135360,8 @@ var ts;
                     // (But do if we didn't find anything, e.g. 'package.json' missing.)
                     var foundGlobal = false;
                     if (fragmentDirectory === undefined) {
-                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
-                            var moduleName = _c[_b];
+                        for (var _d = 0, _e = enumerateNodeModulesVisibleToScript(host, scriptPath); _d < _e.length; _d++) {
+                            var moduleName = _e[_d];
                             var moduleResult = nameAndKind(moduleName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined);
                             if (!result.has(moduleResult.name)) {
                                 foundGlobal = true;
@@ -135184,7 +135376,22 @@ var ts;
                                 getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                             }
                         };
-                        if (fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions)) {
+                        var checkExports_1 = function (packageFile, packageDirectory, fragmentSubpath) {
+                            var packageJson = ts.readJson(packageFile, host);
+                            var exports = packageJson.exports;
+                            if (exports) {
+                                if (typeof exports !== "object" || exports === null) { // eslint-disable-line no-null/no-null
+                                    return true; // null exports or entrypoint only, no sub-modules available
+                                }
+                                var keys = ts.getOwnKeys(exports);
+                                var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
+                                addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions_1)); }, ts.comparePatternKeys);
+                                return true;
+                            }
+                            return false;
+                        };
+                        var shouldCheckExports = fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions);
+                        if (shouldCheckExports) {
                             var nodeModulesDirectoryLookup_1 = ancestorLookup;
                             ancestorLookup = function (ancestor) {
                                 var components = ts.getPathComponents(fragment);
@@ -135203,23 +135410,46 @@ var ts;
                                 var packageDirectory = ts.combinePaths(ancestor, "node_modules", packagePath);
                                 var packageFile = ts.combinePaths(packageDirectory, "package.json");
                                 if (ts.tryFileExists(host, packageFile)) {
-                                    var packageJson = ts.readJson(packageFile, host);
-                                    var exports_1 = packageJson.exports;
-                                    if (exports_1) {
-                                        if (typeof exports_1 !== "object" || exports_1 === null) { // eslint-disable-line no-null/no-null
-                                            return; // null exports or entrypoint only, no sub-modules available
-                                        }
-                                        var keys = ts.getOwnKeys(exports_1);
-                                        var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                                        var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
-                                        addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports_1[key], conditions_1)); }, ts.comparePatternKeys);
+                                    var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
+                                    if (checkExports_1(packageFile, packageDirectory, fragmentSubpath)) {
                                         return;
                                     }
                                 }
                                 return nodeModulesDirectoryLookup_1(ancestor);
                             };
                         }
-                        ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        var pnpapi = typeof process.versions.pnp === "undefined" ? undefined : (_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath);
+                        if (pnpapi) {
+                            // Splits a require request into its components, or return null if the request is a file path
+                            var pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+                            var dependencyNameMatch = fragment.match(pathRegExp);
+                            if (dependencyNameMatch) {
+                                var dependencyName = dependencyNameMatch[1], subPath = dependencyNameMatch[2];
+                                var unqualified = void 0;
+                                try {
+                                    unqualified = pnpapi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+                                }
+                                catch (_f) {
+                                    // It's fine if the resolution fails
+                                }
+                                if (unqualified) {
+                                    var packageDirectory = ts.normalizePath(unqualified);
+                                    var shouldGetCompletions = true;
+                                    if (shouldCheckExports) {
+                                        var packageFile = ts.combinePaths(packageDirectory, "package.json");
+                                        if (ts.tryFileExists(host, packageFile) && checkExports_1(packageFile, packageDirectory, subPath)) {
+                                            shouldGetCompletions = false;
+                                        }
+                                    }
+                                    if (shouldGetCompletions) {
+                                        getCompletionEntriesForDirectoryFragment(subPath, packageDirectory, extensionOptions, host, /*exclude*/ undefined, result);
+                                    }
+                                }
+                            }
+                        }
+                        else {
+                            ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        }
                     }
                 }
                 return ts.arrayFrom(result.values());
@@ -135350,6 +135580,7 @@ var ts;
                 return addReplacementSpans(toComplete, range.pos + prefix.length, ts.arrayFrom(names.values()));
             }
             function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
+                var _a, _b;
                 if (result === void 0) { result = createNameAndKindSet(); }
                 // Check for typings specified in compiler options
                 var seen = new ts.Map();
@@ -135358,11 +135589,19 @@ var ts;
                     var root = typeRoots_1[_i];
                     getCompletionEntriesFromDirectories(root);
                 }
-                // Also get all @types typings installed in visible node_modules directories
-                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
-                    var packageJson = _b[_a];
-                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
-                    getCompletionEntriesFromDirectories(typesDir);
+                if (typeof process.versions.pnp !== "undefined" && ((_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath))) {
+                    for (var _c = 0, _d = ts.getPnpTypeRoots(scriptPath); _c < _d.length; _c++) {
+                        var root = _d[_c];
+                        getCompletionEntriesFromDirectories(root);
+                    }
+                }
+                else {
+                    // Also get all @types typings installed in visible node_modules directories
+                    for (var _e = 0, _f = ts.findPackageJsons(scriptPath, host); _e < _f.length; _e++) {
+                        var packageJson = _f[_e];
+                        var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
+                        getCompletionEntriesFromDirectories(typesDir);
+                    }
                 }
                 return result;
                 function getCompletionEntriesFromDirectories(directory) {
@@ -166526,9 +166765,9 @@ var ts;
                 if (isTopLevelDeclarationStatement(statement) &&
                     !isExported(sourceFile, statement, useEs6Exports) &&
                     forEachTopLevelDeclaration(statement, function (d) { return needExport.has(ts.Debug.checkDefined(d.symbol)); })) {
-                    var exports = addExport(statement, useEs6Exports);
-                    if (exports)
-                        return exports;
+                    var exports_1 = addExport(statement, useEs6Exports);
+                    if (exports_1)
+                        return exports_1;
                 }
                 return statement;
             });
diff --git a/lib/typescriptServices.js b/lib/typescriptServices.js
index 59e716a7b..e9a4bad07 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/typescriptServices.js
+++ b/lib/typescriptServices.js
@@ -7293,6 +7293,11 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                // The PnP runtime is always case-sensitive
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    return true;
+                }
                 // win32\win64 are case insensitive platforms
                 if (platform === "win32" || platform === "win64") {
                     return false;
@@ -43464,18 +43469,17 @@ var ts;
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
     /**
      * Returns the path to every node_modules/@types directory from some ancestor directory.
-     * Returns undefined if there are none.
      */
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
             // And if it doesn't exist, tough.
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -43486,6 +43490,42 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* Comparison.EqualTo */;
     }
+    /**
+     * @internal
+     */
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        // Some TS consumers pass relative paths that aren't normalized
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            // eslint-disable-next-line no-null/no-null
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
@@ -43627,7 +43667,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -44355,7 +44397,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -45310,8 +45354,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, /* rest */ undefined, /* packageDirectory */ undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, /*moduleName*/ undefined, /*nodeModulesDirectory*/ undefined, /*nodeModulesDirectoryExists*/ true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         // But only if we're not respecting export maps (if we are, we might redirect around this location)
@@ -45338,15 +45390,18 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -45540,6 +45595,61 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    /**
+     * We only allow PnP to be used as a resolution strategy if TypeScript
+     * itself is executed under a PnP runtime (and we only allow it to access
+     * the current PnP runtime, not any on the disk). This ensures that we
+     * don't execute potentially malicious code that didn't already have a
+     * chance to be executed (if we're running within the runtime, it means
+     * that the runtime has already been executed).
+     * @internal
+     */
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+            // Nothing to do
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    /* @internal */
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 /* @internal */
 var ts;
@@ -118128,6 +118238,8 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         /** Reload completely by re-reading contents of config file from disk and updating program */
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        /** Reload the resolutions */
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     /**
      * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
@@ -125531,6 +125643,30 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                // eslint-disable-next-line no-null/no-null
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    // Don't use the package name when the imported file is inside
+                    // the source directory (prefer a relative path instead)
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        // The last character from packageLocation is the trailing "/", we want to point to it
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -125570,18 +125706,24 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            // Get a path that's relative to node_modules or the importing file's path
-            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they
+            // are located in a weird path apparently outside of the source directory
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                // Get a path that's relative to node_modules or the importing file's path
+                // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
             // If the module was found in @types, get the actual Node package name
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
             // For classic resolution, only allow importing from node_modules/@types, not other node_modules
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -126474,6 +126616,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         // Members for CompilerHost
@@ -126560,6 +126706,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -126592,7 +126742,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -126602,7 +126753,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -126816,6 +126967,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -126831,6 +126988,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(/*forceAllFilesAsInvalidated*/ true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
@@ -133227,7 +133388,7 @@ var ts;
      * Don't include something from a `node_modules` that isn't actually reachable by a global import.
      * A relative import to node_modules is usually a bad idea.
      */
-    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+    function isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath) {
         // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
         var toNodeModules = ts.forEachAncestorDirectory(toPath, function (ancestor) { return ts.getBaseFileName(ancestor) === "node_modules" ? ancestor : undefined; });
         var toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
@@ -133235,6 +133396,36 @@ var ts;
             || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent)
             || (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
     }
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function isImportablePathPnp(fromPath, toPath) {
+        var pnpApi = getPnpApi(fromPath);
+        var fromLocator = pnpApi.findPackageLocator(fromPath);
+        var toLocator = pnpApi.findPackageLocator(toPath);
+        // eslint-disable-next-line no-null/no-null
+        if (toLocator === null) {
+            return false;
+        }
+        var fromInfo = pnpApi.getPackageInformation(fromLocator);
+        var toReference = fromInfo.packageDependencies.get(toLocator.name);
+        return toReference === toLocator.reference;
+    }
+    function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
+        if (getPnpApi(fromPath)) {
+            return isImportablePathPnp(fromPath, toPath);
+        }
+        else {
+            return isImportablePathNode(fromPath, toPath, getCanonicalFileName, globalCachePath);
+        }
+    }
     function forEachExternalModuleToImportFrom(program, host, preferences, useAutoImportProvider, cb) {
         var _a, _b;
         var useCaseSensitiveFileNames = ts.hostUsesCaseSensitiveFileNames(host);
@@ -135146,6 +135337,7 @@ var ts;
              *          This includes all files that are found in node_modules/moduleName/ with acceptable file extensions
              */
             function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, compilerOptions, host, includeExtensionsOption, typeChecker) {
+                var _a, _b;
                 var baseUrl = compilerOptions.baseUrl, paths = compilerOptions.paths;
                 var result = createNameAndKindSet();
                 var extensionOptions = getExtensionOptions(compilerOptions, includeExtensionsOption);
@@ -135158,8 +135350,8 @@ var ts;
                     }
                 }
                 var fragmentDirectory = getFragmentDirectory(fragment);
-                for (var _i = 0, _a = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _a.length; _i++) {
-                    var ambientName = _a[_i];
+                for (var _i = 0, _c = getAmbientModuleCompletions(fragment, fragmentDirectory, typeChecker); _i < _c.length; _i++) {
+                    var ambientName = _c[_i];
                     result.add(nameAndKind(ambientName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined));
                 }
                 getCompletionEntriesFromTypings(host, compilerOptions, scriptPath, fragmentDirectory, extensionOptions, result);
@@ -135168,8 +135360,8 @@ var ts;
                     // (But do if we didn't find anything, e.g. 'package.json' missing.)
                     var foundGlobal = false;
                     if (fragmentDirectory === undefined) {
-                        for (var _b = 0, _c = enumerateNodeModulesVisibleToScript(host, scriptPath); _b < _c.length; _b++) {
-                            var moduleName = _c[_b];
+                        for (var _d = 0, _e = enumerateNodeModulesVisibleToScript(host, scriptPath); _d < _e.length; _d++) {
+                            var moduleName = _e[_d];
                             var moduleResult = nameAndKind(moduleName, "external module name" /* ScriptElementKind.externalModuleName */, /*extension*/ undefined);
                             if (!result.has(moduleResult.name)) {
                                 foundGlobal = true;
@@ -135184,7 +135376,22 @@ var ts;
                                 getCompletionEntriesForDirectoryFragment(fragment, nodeModules, extensionOptions, host, /*exclude*/ undefined, result);
                             }
                         };
-                        if (fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions)) {
+                        var checkExports_1 = function (packageFile, packageDirectory, fragmentSubpath) {
+                            var packageJson = ts.readJson(packageFile, host);
+                            var exports = packageJson.exports;
+                            if (exports) {
+                                if (typeof exports !== "object" || exports === null) { // eslint-disable-line no-null/no-null
+                                    return true; // null exports or entrypoint only, no sub-modules available
+                                }
+                                var keys = ts.getOwnKeys(exports);
+                                var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
+                                addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions_1)); }, ts.comparePatternKeys);
+                                return true;
+                            }
+                            return false;
+                        };
+                        var shouldCheckExports = fragmentDirectory && isEmitModuleResolutionRespectingExportMaps(compilerOptions);
+                        if (shouldCheckExports) {
                             var nodeModulesDirectoryLookup_1 = ancestorLookup;
                             ancestorLookup = function (ancestor) {
                                 var components = ts.getPathComponents(fragment);
@@ -135203,23 +135410,46 @@ var ts;
                                 var packageDirectory = ts.combinePaths(ancestor, "node_modules", packagePath);
                                 var packageFile = ts.combinePaths(packageDirectory, "package.json");
                                 if (ts.tryFileExists(host, packageFile)) {
-                                    var packageJson = ts.readJson(packageFile, host);
-                                    var exports_1 = packageJson.exports;
-                                    if (exports_1) {
-                                        if (typeof exports_1 !== "object" || exports_1 === null) { // eslint-disable-line no-null/no-null
-                                            return; // null exports or entrypoint only, no sub-modules available
-                                        }
-                                        var keys = ts.getOwnKeys(exports_1);
-                                        var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                                        var conditions_1 = mode === ts.ModuleKind.ESNext ? ["node", "import", "types"] : ["node", "require", "types"];
-                                        addCompletionEntriesFromPathsOrExports(result, fragmentSubpath, packageDirectory, extensionOptions, host, keys, function (key) { return ts.singleElementArray(getPatternFromFirstMatchingCondition(exports_1[key], conditions_1)); }, ts.comparePatternKeys);
+                                    var fragmentSubpath = components.join("/") + (components.length && ts.hasTrailingDirectorySeparator(fragment) ? "/" : "");
+                                    if (checkExports_1(packageFile, packageDirectory, fragmentSubpath)) {
                                         return;
                                     }
                                 }
                                 return nodeModulesDirectoryLookup_1(ancestor);
                             };
                         }
-                        ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        var pnpapi = typeof process.versions.pnp === "undefined" ? undefined : (_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath);
+                        if (pnpapi) {
+                            // Splits a require request into its components, or return null if the request is a file path
+                            var pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+                            var dependencyNameMatch = fragment.match(pathRegExp);
+                            if (dependencyNameMatch) {
+                                var dependencyName = dependencyNameMatch[1], subPath = dependencyNameMatch[2];
+                                var unqualified = void 0;
+                                try {
+                                    unqualified = pnpapi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+                                }
+                                catch (_f) {
+                                    // It's fine if the resolution fails
+                                }
+                                if (unqualified) {
+                                    var packageDirectory = ts.normalizePath(unqualified);
+                                    var shouldGetCompletions = true;
+                                    if (shouldCheckExports) {
+                                        var packageFile = ts.combinePaths(packageDirectory, "package.json");
+                                        if (ts.tryFileExists(host, packageFile) && checkExports_1(packageFile, packageDirectory, subPath)) {
+                                            shouldGetCompletions = false;
+                                        }
+                                    }
+                                    if (shouldGetCompletions) {
+                                        getCompletionEntriesForDirectoryFragment(subPath, packageDirectory, extensionOptions, host, /*exclude*/ undefined, result);
+                                    }
+                                }
+                            }
+                        }
+                        else {
+                            ts.forEachAncestorDirectory(scriptPath, ancestorLookup);
+                        }
                     }
                 }
                 return ts.arrayFrom(result.values());
@@ -135350,6 +135580,7 @@ var ts;
                 return addReplacementSpans(toComplete, range.pos + prefix.length, ts.arrayFrom(names.values()));
             }
             function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDirectory, extensionOptions, result) {
+                var _a, _b;
                 if (result === void 0) { result = createNameAndKindSet(); }
                 // Check for typings specified in compiler options
                 var seen = new ts.Map();
@@ -135358,11 +135589,19 @@ var ts;
                     var root = typeRoots_1[_i];
                     getCompletionEntriesFromDirectories(root);
                 }
-                // Also get all @types typings installed in visible node_modules directories
-                for (var _a = 0, _b = ts.findPackageJsons(scriptPath, host); _a < _b.length; _a++) {
-                    var packageJson = _b[_a];
-                    var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
-                    getCompletionEntriesFromDirectories(typesDir);
+                if (typeof process.versions.pnp !== "undefined" && ((_b = (_a = require("module")).findPnpApi) === null || _b === void 0 ? void 0 : _b.call(_a, scriptPath))) {
+                    for (var _c = 0, _d = ts.getPnpTypeRoots(scriptPath); _c < _d.length; _c++) {
+                        var root = _d[_c];
+                        getCompletionEntriesFromDirectories(root);
+                    }
+                }
+                else {
+                    // Also get all @types typings installed in visible node_modules directories
+                    for (var _e = 0, _f = ts.findPackageJsons(scriptPath, host); _e < _f.length; _e++) {
+                        var packageJson = _f[_e];
+                        var typesDir = ts.combinePaths(ts.getDirectoryPath(packageJson), "node_modules/@types");
+                        getCompletionEntriesFromDirectories(typesDir);
+                    }
                 }
                 return result;
                 function getCompletionEntriesFromDirectories(directory) {
@@ -166526,9 +166765,9 @@ var ts;
                 if (isTopLevelDeclarationStatement(statement) &&
                     !isExported(sourceFile, statement, useEs6Exports) &&
                     forEachTopLevelDeclaration(statement, function (d) { return needExport.has(ts.Debug.checkDefined(d.symbol)); })) {
-                    var exports = addExport(statement, useEs6Exports);
-                    if (exports)
-                        return exports;
+                    var exports_1 = addExport(statement, useEs6Exports);
+                    if (exports_1)
+                        return exports_1;
                 }
                 return statement;
             });
diff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js
index ed96b5050..aa2287106 100644
semver exclusivity >=4.9.2-rc <4.9.4
--- a/lib/typingsInstaller.js
+++ b/lib/typingsInstaller.js
@@ -7283,6 +7283,11 @@ var ts;
                     : new Buffer(input, encoding);
             }
             function isFileSystemCaseSensitive() {
+                // The PnP runtime is always case-sensitive
+                // @ts-ignore
+                if (process.versions.pnp) {
+                    return true;
+                }
                 // win32\win64 are case insensitive platforms
                 if (platform === "win32" || platform === "win64") {
                     return false;
@@ -43454,18 +43459,17 @@ var ts;
     ts.getEffectiveTypeRoots = getEffectiveTypeRoots;
     /**
      * Returns the path to every node_modules/@types directory from some ancestor directory.
-     * Returns undefined if there are none.
      */
-    function getDefaultTypeRoots(currentDirectory, host) {
+    function getNodeModulesTypeRoots(currentDirectory, host) {
         if (!host.directoryExists) {
             return [ts.combinePaths(currentDirectory, nodeModulesAtTypes)];
             // And if it doesn't exist, tough.
         }
-        var typeRoots;
+        var typeRoots = [];
         ts.forEachAncestorDirectory(ts.normalizePath(currentDirectory), function (directory) {
             var atTypes = ts.combinePaths(directory, nodeModulesAtTypes);
             if (host.directoryExists(atTypes)) {
-                (typeRoots || (typeRoots = [])).push(atTypes);
+                typeRoots.push(atTypes);
             }
             return undefined;
         });
@@ -43476,6 +43480,42 @@ var ts;
         var useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
         return ts.comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* Comparison.EqualTo */;
     }
+    /**
+     * @internal
+     */
+    function getPnpTypeRoots(currentDirectory) {
+        var pnpapi = getPnpApi(currentDirectory);
+        if (!pnpapi) {
+            return [];
+        }
+        // Some TS consumers pass relative paths that aren't normalized
+        currentDirectory = ts.sys.resolvePath(currentDirectory);
+        var currentPackage = pnpapi.findPackageLocator("".concat(currentDirectory, "/"));
+        if (!currentPackage) {
+            return [];
+        }
+        var packageDependencies = pnpapi.getPackageInformation(currentPackage).packageDependencies;
+        var typeRoots = [];
+        for (var _i = 0, _a = Array.from(packageDependencies.entries()); _i < _a.length; _i++) {
+            var _b = _a[_i], name = _b[0], referencish = _b[1];
+            // eslint-disable-next-line no-null/no-null
+            if (name.startsWith(typesPackagePrefix) && referencish !== null) {
+                var dependencyLocator = pnpapi.getLocator(name, referencish);
+                var packageLocation = pnpapi.getPackageInformation(dependencyLocator).packageLocation;
+                typeRoots.push(ts.getDirectoryPath(packageLocation));
+            }
+        }
+        return typeRoots;
+    }
+    ts.getPnpTypeRoots = getPnpTypeRoots;
+    var typesPackagePrefix = "@types/";
+    function getDefaultTypeRoots(currentDirectory, host) {
+        var nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+        var pnpTypes = getPnpTypeRoots(currentDirectory);
+        if (nmTypes.length > 0 || pnpTypes.length > 0) {
+            return __spreadArray(__spreadArray([], nmTypes, true), pnpTypes, true);
+        }
+    }
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
      * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
@@ -43617,7 +43657,9 @@ var ts;
                 }
                 var result_4;
                 if (!ts.isExternalModuleNameRelative(typeReferenceDirectiveName)) {
-                    var searchResult = loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
+                    var searchResult = getPnpApi(initialLocationForSecondaryLookup)
+                        ? tryLoadModuleUsingPnpResolution(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined)
+                        : loadModuleFromNearestNodeModulesDirectory(Extensions.DtsOnly, typeReferenceDirectiveName, initialLocationForSecondaryLookup, moduleResolutionState, /*cache*/ undefined, /*redirectedReference*/ undefined);
                     result_4 = searchResult && searchResult.value;
                 }
                 else {
@@ -44345,7 +44387,9 @@ var ts;
                     if (traceEnabled) {
                         trace(host, ts.Diagnostics.Loading_module_0_from_node_modules_folder_target_file_type_1, moduleName, Extensions[extensions]);
                     }
-                    resolved_1 = loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
+                    resolved_1 = getPnpApi(containingDirectory)
+                        ? tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference)
+                        : loadModuleFromNearestNodeModulesDirectory(extensions, moduleName, containingDirectory, state, cache, redirectedReference);
                 }
                 if (!resolved_1)
                     return undefined;
@@ -45300,8 +45344,16 @@ var ts;
         }
     }
     function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-        var _a;
         var candidate = ts.normalizePath(ts.combinePaths(nodeModulesDirectory, moduleName));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, /* rest */ undefined, /* packageDirectory */ undefined);
+    }
+    function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+        var candidate = ts.normalizePath(ts.combinePaths(packageDirectory, rest));
+        return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, /*moduleName*/ undefined, /*nodeModulesDirectory*/ undefined, /*nodeModulesDirectoryExists*/ true, state, cache, redirectedReference, candidate, rest, packageDirectory);
+    }
+    function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+        var _a;
+        var _b;
         // First look for a nested package.json, as in `node_modules/foo/bar/package.json`.
         var packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
         // But only if we're not respecting export maps (if we are, we might redirect around this location)
@@ -45328,15 +45380,18 @@ var ts;
             }
             return withPackageId(packageInfo, pathAndExtension);
         };
-        var _b = parsePackageName(moduleName), packageName = _b.packageName, rest = _b.rest;
-        var packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
+        var packageName;
+        if (rest === undefined)
+            (_a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest);
+        if (packageDirectory === undefined)
+            packageDirectory = ts.combinePaths(nodeModulesDirectory, packageName);
         if (rest !== "") {
             // Previous `packageInfo` may have been from a nested package.json; ensure we have the one from the package root now.
             packageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state);
         }
         // package exports are higher priority than file/directory/typesVersions lookups and (and, if there's exports present, blocks them)
         if (packageInfo && packageInfo.contents.packageJsonContent.exports && state.features & NodeResolutionFeatures.Exports) {
-            return (_a = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _a === void 0 ? void 0 : _a.value;
+            return (_b = loadModuleFromExports(packageInfo, extensions, ts.combinePaths(".", rest), state, cache, redirectedReference)) === null || _b === void 0 ? void 0 : _b.value;
         }
         if (rest !== "" && packageInfo && packageInfo.contents.versionPaths) {
             if (state.traceEnabled) {
@@ -45530,6 +45585,61 @@ var ts;
             trace.apply(void 0, __spreadArray([state.host, diagnostic], args, false));
         }
     }
+    /**
+     * We only allow PnP to be used as a resolution strategy if TypeScript
+     * itself is executed under a PnP runtime (and we only allow it to access
+     * the current PnP runtime, not any on the disk). This ensures that we
+     * don't execute potentially malicious code that didn't already have a
+     * chance to be executed (if we're running within the runtime, it means
+     * that the runtime has already been executed).
+     * @internal
+     */
+    function getPnpApi(path) {
+        if (typeof process.versions.pnp === "undefined") {
+            return undefined;
+        }
+        var findPnpApi = require("module").findPnpApi;
+        if (findPnpApi === undefined) {
+            return undefined;
+        }
+        return findPnpApi("".concat(path, "/"));
+    }
+    function loadPnpPackageResolution(packageName, containingDirectory) {
+        try {
+            var resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, "".concat(containingDirectory, "/"), { considerBuiltins: false });
+            return ts.normalizeSlashes(resolution).replace(/\/$/, "");
+        }
+        catch (_a) {
+            // Nothing to do
+        }
+    }
+    function loadPnpTypePackageResolution(packageName, containingDirectory) {
+        return loadPnpPackageResolution(getTypesPackageName(packageName), containingDirectory);
+    }
+    /* @internal */
+    function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+        var _a = parsePackageName(moduleName), packageName = _a.packageName, rest = _a.rest;
+        var packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+        var packageFullResolution = packageResolution
+            ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference)
+            : undefined;
+        var resolved;
+        if (packageFullResolution) {
+            resolved = packageFullResolution;
+        }
+        else if (extensions === Extensions.TypeScript || extensions === Extensions.DtsOnly) {
+            var typePackageResolution = loadPnpTypePackageResolution(packageName, containingDirectory);
+            var typePackageFullResolution = typePackageResolution
+                ? loadModuleFromPnpResolution(Extensions.DtsOnly, typePackageResolution, rest, state, cache, redirectedReference)
+                : undefined;
+            if (typePackageFullResolution) {
+                resolved = typePackageFullResolution;
+            }
+        }
+        if (resolved) {
+            return toSearchResult(resolved);
+        }
+    }
 })(ts || (ts = {}));
 /* @internal */
 var ts;
@@ -118118,6 +118228,8 @@ var ts;
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Partial"] = 1] = "Partial";
         /** Reload completely by re-reading contents of config file from disk and updating program */
         ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Full"] = 2] = "Full";
+        /** Reload the resolutions */
+        ConfigFileProgramReloadLevel[ConfigFileProgramReloadLevel["Resolutions"] = 3] = "Resolutions";
     })(ConfigFileProgramReloadLevel = ts.ConfigFileProgramReloadLevel || (ts.ConfigFileProgramReloadLevel = {}));
     /**
      * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
@@ -125521,6 +125633,30 @@ var ts;
                 return undefined;
             }
             var parts = ts.getNodeModulePathParts(path);
+            var packageName;
+            if (!parts && typeof process.versions.pnp !== "undefined") {
+                var findPnpApi = require("module").findPnpApi;
+                var pnpApi = findPnpApi(path);
+                var locator = pnpApi === null || pnpApi === void 0 ? void 0 : pnpApi.findPackageLocator(path);
+                // eslint-disable-next-line no-null/no-null
+                if (locator !== null && locator !== undefined) {
+                    var sourceLocator = pnpApi.findPackageLocator("".concat(sourceDirectory, "/"));
+                    // Don't use the package name when the imported file is inside
+                    // the source directory (prefer a relative path instead)
+                    if (locator === sourceLocator) {
+                        return undefined;
+                    }
+                    var information = pnpApi.getPackageInformation(locator);
+                    packageName = locator.name;
+                    parts = {
+                        topLevelNodeModulesIndex: undefined,
+                        topLevelPackageNameIndex: undefined,
+                        // The last character from packageLocation is the trailing "/", we want to point to it
+                        packageRootIndex: information.packageLocation.length - 1,
+                        fileNameIndex: path.lastIndexOf("/"),
+                    };
+                }
+            }
             if (!parts) {
                 return undefined;
             }
@@ -125560,18 +125696,24 @@ var ts;
             if (isRedirect && !isPackageRootPath) {
                 return undefined;
             }
-            var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-            // Get a path that's relative to node_modules or the importing file's path
-            // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
-            var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-            if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-                return undefined;
+            // If PnP is enabled the node_modules entries we'll get will always be relevant even if they
+            // are located in a weird path apparently outside of the source directory
+            if (typeof process.versions.pnp === "undefined") {
+                var globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+                // Get a path that's relative to node_modules or the importing file's path
+                // if node_modules folder is in this folder or any of its parent folders, no need to keep it.
+                var pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+                if (!(ts.startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && ts.startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+                    return undefined;
+                }
             }
             // If the module was found in @types, get the actual Node package name
-            var nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-            var packageName = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+            var nodeModulesDirectoryName = typeof packageName !== "undefined"
+                ? packageName + moduleSpecifier.substring(parts.packageRootIndex)
+                : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+            var packageNameFromPath = ts.getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
             // For classic resolution, only allow importing from node_modules/@types, not other node_modules
-            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageName === nodeModulesDirectoryName ? undefined : packageName;
+            return ts.getEmitModuleResolutionKind(options) === ts.ModuleResolutionKind.Classic && packageNameFromPath === nodeModulesDirectoryName ? undefined : packageNameFromPath;
             function tryDirectoryWithPackageJson(packageRootIndex) {
                 var _a, _b;
                 var packageRootPath = path.substring(0, packageRootIndex);
@@ -126464,6 +126606,10 @@ var ts;
         if (configFileName) {
             configFileWatcher = watchFile(configFileName, scheduleProgramReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
         }
+        var pnpFileWatcher;
+        if (typeof process.versions.pnp !== "undefined") {
+            pnpFileWatcher = watchFile(require.resolve("pnpapi"), scheduleResolutionReload, ts.PollingInterval.High, watchOptions, ts.WatchType.ConfigFile);
+        }
         var compilerHost = ts.createCompilerHostFromProgramHost(host, function () { return compilerOptions; }, directoryStructureHost);
         ts.setGetSourceFileAsHashVersioned(compilerHost, host);
         // Members for CompilerHost
@@ -126550,6 +126696,10 @@ var ts;
                 configFileWatcher.close();
                 configFileWatcher = undefined;
             }
+            if (pnpFileWatcher) {
+                pnpFileWatcher.close();
+                pnpFileWatcher = undefined;
+            }
             extendedConfigCache === null || extendedConfigCache === void 0 ? void 0 : extendedConfigCache.clear();
             extendedConfigCache = undefined;
             if (sharedExtendedConfigFileWatchers) {
@@ -126582,7 +126732,8 @@ var ts;
         function getCurrentProgram() {
             return builderProgram && builderProgram.getProgramOrUndefined();
         }
-        function synchronizeProgram() {
+        function synchronizeProgram(forceAllFilesAsInvalidated) {
+            if (forceAllFilesAsInvalidated === void 0) { forceAllFilesAsInvalidated = false; }
             writeLog("Synchronizing program");
             clearInvalidateResolutionsOfFailedLookupLocations();
             var program = getCurrentBuilderProgram();
@@ -126592,7 +126743,7 @@ var ts;
                     resolutionCache.clear();
                 }
             }
-            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+            var hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? ts.returnTrue : customHasInvalidatedResolutions);
             var _a = ts.changeCompilerHostLikeToUseCache(compilerHost, toPath), originalReadFile = _a.originalReadFile, originalFileExists = _a.originalFileExists, originalDirectoryExists = _a.originalDirectoryExists, originalCreateDirectory = _a.originalCreateDirectory, originalWriteFile = _a.originalWriteFile;
             if (ts.isProgramUptoDate(getCurrentProgram(), rootFileNames, compilerOptions, getSourceVersion, function (fileName) { return compilerHost.fileExists(fileName); }, hasInvalidatedResolutions, hasChangedAutomaticTypeDirectiveNames, getParsedCommandLine, projectReferences)) {
                 if (hasChangedConfigFileParsingErrors) {
@@ -126806,6 +126957,12 @@ var ts;
             reloadLevel = ts.ConfigFileProgramReloadLevel.Full;
             scheduleProgramUpdate();
         }
+        function scheduleResolutionReload() {
+            writeLog("Clearing resolutions");
+            resolutionCache.clear();
+            reloadLevel = ts.ConfigFileProgramReloadLevel.Resolutions;
+            scheduleProgramUpdate();
+        }
         function updateProgramWithWatchStatus() {
             timerToUpdateProgram = undefined;
             reportFileChangeDetectedOnCreateProgram = true;
@@ -126821,6 +126978,10 @@ var ts;
                     ts.perfLogger.logStartUpdateProgram("FullConfigReload");
                     reloadConfigFile();
                     break;
+                case ts.ConfigFileProgramReloadLevel.Resolutions:
+                    ts.perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+                    synchronizeProgram(/*forceAllFilesAsInvalidated*/ true);
+                    break;
                 default:
                     ts.perfLogger.logStartUpdateProgram("SynchronizeProgram");
                     synchronizeProgram();
