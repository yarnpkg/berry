diff --git a/lib/tsc.js b/lib/tsc.js
index 92bf3cf99..5df945acb 100644
semver exclusivity >=5.0.1-rc <5.1.0-beta
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -5153,6 +5153,9 @@ var sys = (() => {
       return Buffer2.from && Buffer2.from !== Int8Array.from ? Buffer2.from(input, encoding) : new Buffer2(input, encoding);
     }
     function isFileSystemCaseSensitive() {
+      if (typeof process.versions.pnp !== `undefined`) {
+        return true;
+      }
       if (platform === "win32" || platform === "win64") {
         return false;
       }
@@ -36335,6 +36338,46 @@ function getDefaultValueForOption(option) {
   }
 }
 
+// src/compiler/pnp.ts
+function getPnpApi(path) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  const { findPnpApi } = require("module");
+  if (findPnpApi) {
+    return findPnpApi(`${path}/`);
+  }
+}
+function getPnpApiPath(path) {
+  var _a2;
+  return (_a2 = getPnpApi(path)) == null ? void 0 : _a2.resolveRequest(
+    "pnpapi",
+    /*issuer*/
+    null
+  );
+}
+function getPnpTypeRoots(currentDirectory) {
+  const pnpApi = getPnpApi(currentDirectory);
+  if (!pnpApi) {
+    return [];
+  }
+  currentDirectory = resolvePath(currentDirectory);
+  const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+  if (!currentPackage) {
+    return [];
+  }
+  const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+  const typeRoots = [];
+  for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+    if (name.startsWith(`@types/`) && referencish !== null) {
+      const dependencyLocator = pnpApi.getLocator(name, referencish);
+      const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+      typeRoots.push(getDirectoryPath(packageLocation));
+    }
+  }
+  return typeRoots;
+}
+
 // src/compiler/moduleNameResolver.ts
 function trace(host) {
   host.trace(formatMessage.apply(void 0, arguments));
@@ -36545,7 +36588,7 @@ function getEffectiveTypeRoots(options, host) {
     return getDefaultTypeRoots(currentDirectory, host);
   }
 }
-function getDefaultTypeRoots(currentDirectory, host) {
+function getNodeModulesTypeRoots(currentDirectory, host) {
   if (!host.directoryExists) {
     return [combinePaths(currentDirectory, nodeModulesAtTypes)];
   }
@@ -36564,6 +36607,15 @@ function arePathsEqual(path1, path2, host) {
   const useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
   return comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* EqualTo */;
 }
+function getDefaultTypeRoots(currentDirectory, host) {
+  const nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+  const pnpTypes = getPnpTypeRoots(currentDirectory);
+  if (nmTypes == null ? void 0 : nmTypes.length) {
+    return [...nmTypes, ...pnpTypes];
+  } else if (pnpTypes.length) {
+    return pnpTypes;
+  }
+}
 function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
   const resolvedFileName = realPath(fileName, host, traceEnabled);
   const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -38400,7 +38452,15 @@ function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName,
     return lookup(secondaryExtensions);
   }
   function lookup(extensions2) {
-    return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+    const issuer = normalizeSlashes(directory);
+    if (getPnpApi(issuer)) {
+      const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+      if (resolutionFromCache) {
+        return resolutionFromCache;
+      }
+      return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+    }
+    return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
         if (resolutionFromCache) {
@@ -38435,11 +38495,40 @@ function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, dir
     return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
   }
 }
+function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+  const issuer = normalizeSlashes(directory);
+  if (!typesScopeOnly) {
+    const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+    if (packageResult) {
+      return packageResult;
+    }
+  }
+  if (extensions & 4 /* Declaration */) {
+    return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+  }
+}
 function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-  var _a2, _b, _c;
   const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
   const { packageName, rest } = parsePackageName(moduleName);
   const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+}
+function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+  const candidate = normalizePath(combinePaths(packageDirectory, rest));
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(
+    extensions,
+    /*nodeModulesDirectoryExists*/
+    true,
+    state,
+    cache,
+    redirectedReference,
+    candidate,
+    rest,
+    packageDirectory
+  );
+}
+function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+  var _a2, _b, _c;
   let rootPackageInfo;
   let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
   if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty((_b = (_a2 = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a2.contents.packageJsonContent) != null ? _b : emptyArray, "exports"))) {
@@ -38706,6 +38795,18 @@ function traceIfEnabled(state, diagnostic, ...args) {
     trace(state.host, diagnostic, ...args);
   }
 }
+function loadPnpPackageResolution(packageName, containingDirectory) {
+  try {
+    const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+    return normalizeSlashes(resolution).replace(/\/$/, "");
+  } catch (e) {
+  }
+}
+function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+  const { packageName, rest } = parsePackageName(moduleName);
+  const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+  return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+}
 
 // src/compiler/binder.ts
 function getModuleInstanceState(node, visited) {
@@ -42033,7 +42134,15 @@ function getAllModulePathsWorker(importingFileName, importedFileName, host) {
     /*preferSymlinks*/
     true,
     (path, isRedirect) => {
-      const isInNodeModules = pathContainsNodeModules(path);
+      let isInNodeModules = pathContainsNodeModules(path);
+      const pnpapi = getPnpApi(path);
+      if (!isInNodeModules && pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(importingFileName);
+        const toLocator = pnpapi.findPackageLocator(path);
+        if (fromLocator && toLocator && fromLocator !== toLocator) {
+          isInNodeModules = true;
+        }
+      }
       allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect, isInNodeModules });
       importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
     }
@@ -42225,7 +42334,41 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!host.fileExists || !host.readFile) {
     return void 0;
   }
-  const parts = getNodeModulePathParts(path);
+  let parts = getNodeModulePathParts(path);
+  let pnpPackageName;
+  const pnpApi = getPnpApi(path);
+  if (pnpApi) {
+    const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+    const toLocator = pnpApi.findPackageLocator(path);
+    if (fromLocator === toLocator) {
+      return void 0;
+    }
+    if (fromLocator && toLocator) {
+      const fromInfo = pnpApi.getPackageInformation(fromLocator);
+      if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+        pnpPackageName = toLocator.name;
+      } else {
+        for (const [name, reference] of fromInfo.packageDependencies) {
+          if (Array.isArray(reference)) {
+            if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+              pnpPackageName = name;
+              break;
+            }
+          }
+        }
+      }
+      if (!parts) {
+        const toInfo = pnpApi.getPackageInformation(toLocator);
+        parts = {
+          topLevelNodeModulesIndex: void 0,
+          topLevelPackageNameIndex: void 0,
+          // The last character from packageLocation is the trailing "/", we want to point to it
+          packageRootIndex: toInfo.packageLocation.length - 1,
+          fileNameIndex: path.lastIndexOf(`/`)
+        };
+      }
+    }
+  }
   if (!parts) {
     return void 0;
   }
@@ -42263,14 +42406,16 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (isRedirect && !isPackageRootPath) {
     return void 0;
   }
-  const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-  const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-  if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-    return void 0;
+  if (typeof process.versions.pnp === "undefined") {
+    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+    if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+      return void 0;
+    }
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-  const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+  const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
   function tryDirectoryWithPackageJson(packageRootIndex) {
     var _a2, _b;
     const packageRootPath = path.substring(0, packageRootIndex);
@@ -42283,9 +42428,9 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
       const importMode = overrideMode || importingSourceFile.impliedNodeFormat;
       if (getResolvePackageJsonExports(options)) {
         const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-        const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+        const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
         const conditions = getConditions(options, importMode === 99 /* ESNext */);
-        const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+        const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
         if (fromExports) {
           const withJsExtension = !hasTSFileExtension(fromExports.moduleFileToTry) ? fromExports : { moduleFileToTry: removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
           return { ...withJsExtension, verbatimFromExports: true };
@@ -119306,6 +119451,11 @@ function createWatchProgram(host) {
   if (configFileName) {
     configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
   }
+  let pnpFileWatcher;
+  const pnpApiPath = getPnpApiPath(__filename);
+  if (pnpApiPath) {
+    pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+  }
   const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
   setGetSourceFileAsHashVersioned(compilerHost);
   const getNewSourceFile = compilerHost.getSourceFile;
@@ -119367,6 +119517,10 @@ function createWatchProgram(host) {
       configFileWatcher.close();
       configFileWatcher = void 0;
     }
+    if (pnpFileWatcher) {
+      pnpFileWatcher.close();
+      pnpFileWatcher = void 0;
+    }
     extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
     extendedConfigCache = void 0;
     if (sharedExtendedConfigFileWatchers) {
@@ -119399,7 +119553,7 @@ function createWatchProgram(host) {
   function getCurrentProgram() {
     return builderProgram && builderProgram.getProgramOrUndefined();
   }
-  function synchronizeProgram() {
+  function synchronizeProgram(forceAllFilesAsInvalidated = false) {
     writeLog(`Synchronizing program`);
     Debug.assert(compilerOptions);
     Debug.assert(rootFileNames);
@@ -119411,7 +119565,7 @@ function createWatchProgram(host) {
         resolutionCache.clear();
       }
     }
-    const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+    const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions);
     const {
       originalReadFile,
       originalFileExists,
@@ -119617,6 +119771,12 @@ function createWatchProgram(host) {
     reloadLevel = 2 /* Full */;
     scheduleProgramUpdate();
   }
+  function scheduleResolutionReload() {
+    writeLog("Clearing resolutions");
+    resolutionCache.clear();
+    reloadLevel = 3 /* Resolutions */;
+    scheduleProgramUpdate();
+  }
   function updateProgramWithWatchStatus() {
     timerToUpdateProgram = void 0;
     reportFileChangeDetectedOnCreateProgram = true;
@@ -119632,6 +119792,13 @@ function createWatchProgram(host) {
         perfLogger.logStartUpdateProgram("FullConfigReload");
         reloadConfigFile();
         break;
+      case 3 /* Resolutions */:
+        perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+        synchronizeProgram(
+          /*forceAllFilesAsInvalidated*/
+          true
+        );
+        break;
       default:
         perfLogger.logStartUpdateProgram("SynchronizeProgram");
         synchronizeProgram();
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 20cb517f8..eeac46d44 100644
semver exclusivity >=5.0.1-rc <5.1.0-beta
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -8601,6 +8601,9 @@ var sys = (() => {
       return Buffer2.from && Buffer2.from !== Int8Array.from ? Buffer2.from(input, encoding) : new Buffer2(input, encoding);
     }
     function isFileSystemCaseSensitive() {
+      if (typeof process.versions.pnp !== `undefined`) {
+        return true;
+      }
       if (platform === "win32" || platform === "win64") {
         return false;
       }
@@ -40749,6 +40752,67 @@ function getDefaultValueForOption(option) {
   }
 }
 
+// src/compiler/pnp.ts
+function getPnpApi(path) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  const { findPnpApi } = require("module");
+  if (findPnpApi) {
+    return findPnpApi(`${path}/`);
+  }
+}
+function getPnpApiPath(path) {
+  var _a2;
+  return (_a2 = getPnpApi(path)) == null ? void 0 : _a2.resolveRequest(
+    "pnpapi",
+    /*issuer*/
+    null
+  );
+}
+function getPnpTypeRoots(currentDirectory) {
+  const pnpApi = getPnpApi(currentDirectory);
+  if (!pnpApi) {
+    return [];
+  }
+  currentDirectory = resolvePath(currentDirectory);
+  const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+  if (!currentPackage) {
+    return [];
+  }
+  const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+  const typeRoots = [];
+  for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+    if (name.startsWith(`@types/`) && referencish !== null) {
+      const dependencyLocator = pnpApi.getLocator(name, referencish);
+      const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+      typeRoots.push(getDirectoryPath(packageLocation));
+    }
+  }
+  return typeRoots;
+}
+function isImportablePathPnp(fromPath, toPath3) {
+  const pnpApi = getPnpApi(fromPath);
+  const fromLocator = pnpApi.findPackageLocator(fromPath);
+  const toLocator = pnpApi.findPackageLocator(toPath3);
+  if (toLocator === null) {
+    return false;
+  }
+  const fromInfo = pnpApi.getPackageInformation(fromLocator);
+  const toReference = fromInfo.packageDependencies.get(toLocator.name);
+  if (toReference) {
+    return toReference === toLocator.reference;
+  }
+  for (const reference of fromInfo.packageDependencies.values()) {
+    if (Array.isArray(reference)) {
+      if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
 // src/compiler/moduleNameResolver.ts
 function trace(host) {
   host.trace(formatMessage.apply(void 0, arguments));
@@ -40959,7 +41023,7 @@ function getEffectiveTypeRoots(options, host) {
     return getDefaultTypeRoots(currentDirectory, host);
   }
 }
-function getDefaultTypeRoots(currentDirectory, host) {
+function getNodeModulesTypeRoots(currentDirectory, host) {
   if (!host.directoryExists) {
     return [combinePaths(currentDirectory, nodeModulesAtTypes)];
   }
@@ -40978,6 +41042,15 @@ function arePathsEqual(path1, path2, host) {
   const useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
   return comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* EqualTo */;
 }
+function getDefaultTypeRoots(currentDirectory, host) {
+  const nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+  const pnpTypes = getPnpTypeRoots(currentDirectory);
+  if (nmTypes == null ? void 0 : nmTypes.length) {
+    return [...nmTypes, ...pnpTypes];
+  } else if (pnpTypes.length) {
+    return pnpTypes;
+  }
+}
 function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
   const resolvedFileName = realPath(fileName, host, traceEnabled);
   const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -41202,6 +41275,21 @@ function getConditions(options, esmMode) {
 }
 function resolvePackageNameToPackageJson(packageName, containingDirectory, options, host, cache) {
   const moduleResolutionState = getTemporaryModuleResolutionState(cache == null ? void 0 : cache.getPackageJsonInfoCache(), host, options);
+  const pnpapi = getPnpApi(containingDirectory);
+  if (pnpapi) {
+    try {
+      const resolution = pnpapi.resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+      const candidate = normalizeSlashes(resolution).replace(/\/$/, "");
+      return getPackageJsonInfo(
+        candidate,
+        /*onlyRecordFailures*/
+        false,
+        moduleResolutionState
+      );
+    } catch (e) {
+      return;
+    }
+  }
   return forEachAncestorDirectory(containingDirectory, (ancestorDirectory) => {
     if (getBaseFileName(ancestorDirectory) !== "node_modules") {
       const nodeModulesFolder = combinePaths(ancestorDirectory, "node_modules");
@@ -42953,7 +43041,15 @@ function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName,
     return lookup(secondaryExtensions);
   }
   function lookup(extensions2) {
-    return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+    const issuer = normalizeSlashes(directory);
+    if (getPnpApi(issuer)) {
+      const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+      if (resolutionFromCache) {
+        return resolutionFromCache;
+      }
+      return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+    }
+    return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
         if (resolutionFromCache) {
@@ -42988,11 +43084,40 @@ function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, dir
     return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
   }
 }
+function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+  const issuer = normalizeSlashes(directory);
+  if (!typesScopeOnly) {
+    const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+    if (packageResult) {
+      return packageResult;
+    }
+  }
+  if (extensions & 4 /* Declaration */) {
+    return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+  }
+}
 function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-  var _a2, _b, _c;
   const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
   const { packageName, rest } = parsePackageName(moduleName);
   const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+}
+function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+  const candidate = normalizePath(combinePaths(packageDirectory, rest));
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(
+    extensions,
+    /*nodeModulesDirectoryExists*/
+    true,
+    state,
+    cache,
+    redirectedReference,
+    candidate,
+    rest,
+    packageDirectory
+  );
+}
+function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+  var _a2, _b, _c;
   let rootPackageInfo;
   let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
   if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty((_b = (_a2 = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a2.contents.packageJsonContent) != null ? _b : emptyArray, "exports"))) {
@@ -43259,6 +43384,18 @@ function traceIfEnabled(state, diagnostic, ...args) {
     trace(state.host, diagnostic, ...args);
   }
 }
+function loadPnpPackageResolution(packageName, containingDirectory) {
+  try {
+    const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+    return normalizeSlashes(resolution).replace(/\/$/, "");
+  } catch (e) {
+  }
+}
+function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+  const { packageName, rest } = parsePackageName(moduleName);
+  const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+  return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+}
 
 // src/compiler/binder.ts
 var ModuleInstanceState = /* @__PURE__ */ ((ModuleInstanceState2) => {
@@ -46640,7 +46777,15 @@ function getAllModulePathsWorker(importingFileName, importedFileName, host) {
     /*preferSymlinks*/
     true,
     (path, isRedirect) => {
-      const isInNodeModules = pathContainsNodeModules(path);
+      let isInNodeModules = pathContainsNodeModules(path);
+      const pnpapi = getPnpApi(path);
+      if (!isInNodeModules && pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(importingFileName);
+        const toLocator = pnpapi.findPackageLocator(path);
+        if (fromLocator && toLocator && fromLocator !== toLocator) {
+          isInNodeModules = true;
+        }
+      }
       allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect, isInNodeModules });
       importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
     }
@@ -46832,7 +46977,41 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!host.fileExists || !host.readFile) {
     return void 0;
   }
-  const parts = getNodeModulePathParts(path);
+  let parts = getNodeModulePathParts(path);
+  let pnpPackageName;
+  const pnpApi = getPnpApi(path);
+  if (pnpApi) {
+    const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+    const toLocator = pnpApi.findPackageLocator(path);
+    if (fromLocator === toLocator) {
+      return void 0;
+    }
+    if (fromLocator && toLocator) {
+      const fromInfo = pnpApi.getPackageInformation(fromLocator);
+      if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+        pnpPackageName = toLocator.name;
+      } else {
+        for (const [name, reference] of fromInfo.packageDependencies) {
+          if (Array.isArray(reference)) {
+            if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+              pnpPackageName = name;
+              break;
+            }
+          }
+        }
+      }
+      if (!parts) {
+        const toInfo = pnpApi.getPackageInformation(toLocator);
+        parts = {
+          topLevelNodeModulesIndex: void 0,
+          topLevelPackageNameIndex: void 0,
+          // The last character from packageLocation is the trailing "/", we want to point to it
+          packageRootIndex: toInfo.packageLocation.length - 1,
+          fileNameIndex: path.lastIndexOf(`/`)
+        };
+      }
+    }
+  }
   if (!parts) {
     return void 0;
   }
@@ -46870,14 +47049,16 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (isRedirect && !isPackageRootPath) {
     return void 0;
   }
-  const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-  const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-  if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-    return void 0;
+  if (typeof process.versions.pnp === "undefined") {
+    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+    if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+      return void 0;
+    }
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-  const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+  const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
   function tryDirectoryWithPackageJson(packageRootIndex) {
     var _a2, _b;
     const packageRootPath = path.substring(0, packageRootIndex);
@@ -46890,9 +47071,9 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
       const importMode = overrideMode || importingSourceFile.impliedNodeFormat;
       if (getResolvePackageJsonExports(options)) {
         const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-        const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+        const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
         const conditions = getConditions(options, importMode === 99 /* ESNext */);
-        const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+        const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
         if (fromExports) {
           const withJsExtension = !hasTSFileExtension(fromExports.moduleFileToTry) ? fromExports : { moduleFileToTry: removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
           return { ...withJsExtension, verbatimFromExports: true };
@@ -116699,6 +116880,7 @@ var ConfigFileProgramReloadLevel = /* @__PURE__ */ ((ConfigFileProgramReloadLeve
   ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["None"] = 0] = "None";
   ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Partial"] = 1] = "Partial";
   ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Full"] = 2] = "Full";
+  ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Resolutions"] = 3] = "Resolutions";
   return ConfigFileProgramReloadLevel2;
 })(ConfigFileProgramReloadLevel || {});
 function updateSharedExtendedConfigFileWatcher(projectPath, options, extendedConfigFilesMap, createExtendedConfigFileWatch, toPath3) {
@@ -124206,6 +124388,11 @@ function createWatchProgram(host) {
   if (configFileName) {
     configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
   }
+  let pnpFileWatcher;
+  const pnpApiPath = getPnpApiPath(__filename);
+  if (pnpApiPath) {
+    pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+  }
   const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
   setGetSourceFileAsHashVersioned(compilerHost);
   const getNewSourceFile = compilerHost.getSourceFile;
@@ -124267,6 +124454,10 @@ function createWatchProgram(host) {
       configFileWatcher.close();
       configFileWatcher = void 0;
     }
+    if (pnpFileWatcher) {
+      pnpFileWatcher.close();
+      pnpFileWatcher = void 0;
+    }
     extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
     extendedConfigCache = void 0;
     if (sharedExtendedConfigFileWatchers) {
@@ -124299,7 +124490,7 @@ function createWatchProgram(host) {
   function getCurrentProgram() {
     return builderProgram && builderProgram.getProgramOrUndefined();
   }
-  function synchronizeProgram() {
+  function synchronizeProgram(forceAllFilesAsInvalidated = false) {
     writeLog(`Synchronizing program`);
     Debug.assert(compilerOptions);
     Debug.assert(rootFileNames);
@@ -124311,7 +124502,7 @@ function createWatchProgram(host) {
         resolutionCache.clear();
       }
     }
-    const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+    const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions);
     const {
       originalReadFile,
       originalFileExists,
@@ -124517,6 +124708,12 @@ function createWatchProgram(host) {
     reloadLevel = 2 /* Full */;
     scheduleProgramUpdate();
   }
+  function scheduleResolutionReload() {
+    writeLog("Clearing resolutions");
+    resolutionCache.clear();
+    reloadLevel = 3 /* Resolutions */;
+    scheduleProgramUpdate();
+  }
   function updateProgramWithWatchStatus() {
     timerToUpdateProgram = void 0;
     reportFileChangeDetectedOnCreateProgram = true;
@@ -124532,6 +124729,13 @@ function createWatchProgram(host) {
         perfLogger.logStartUpdateProgram("FullConfigReload");
         reloadConfigFile();
         break;
+      case 3 /* Resolutions */:
+        perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+        synchronizeProgram(
+          /*forceAllFilesAsInvalidated*/
+          true
+        );
+        break;
       default:
         perfLogger.logStartUpdateProgram("SynchronizeProgram");
         synchronizeProgram();
@@ -129982,7 +130186,14 @@ function createPackageJsonImportFilter(fromFile, preferences, host) {
     return false;
   }
   function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
-    if (!stringContains(importedFileName, "node_modules")) {
+    const pnpapi = getPnpApi(importedFileName);
+    if (pnpapi) {
+      const fromLocator = pnpapi.findPackageLocator(fromFile.fileName);
+      const toLocator = pnpapi.findPackageLocator(importedFileName);
+      if (!(fromLocator && toLocator)) {
+        return void 0;
+      }
+    } else if (!stringContains(importedFileName, "node_modules")) {
       return void 0;
     }
     const specifier = ts_moduleSpecifiers_exports.getNodeModulesPackageName(
@@ -130473,6 +130684,9 @@ function isImportableFile(program, from, to, preferences, packageJsonFilter, mod
   return hasImportablePath;
 }
 function isImportablePath(fromPath, toPath3, getCanonicalFileName, globalCachePath) {
+  if (getPnpApi(fromPath)) {
+    return isImportablePathPnp(fromPath, toPath3);
+  }
   const toNodeModules = forEachAncestorDirectory(toPath3, (ancestor) => getBaseFileName(ancestor) === "node_modules" ? ancestor : void 0);
   const toNodeModulesParent = toNodeModules && getDirectoryPath(getCanonicalFileName(toNodeModules));
   return toNodeModulesParent === void 0 || startsWith(getCanonicalFileName(fromPath), toNodeModulesParent) || !!globalCachePath && startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent);
@@ -152323,7 +152537,31 @@ function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, c
           );
         }
       };
-      if (fragmentDirectory && getResolvePackageJsonExports(compilerOptions)) {
+      const checkExports = (packageFile, packageDirectory, fragmentSubpath) => {
+        const packageJson = readJson(packageFile, host);
+        const exports = packageJson.exports;
+        if (exports) {
+          if (typeof exports !== "object" || exports === null) {
+            return true;
+          }
+          const keys = getOwnKeys(exports);
+          const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
+          addCompletionEntriesFromPathsOrExports(
+            result,
+            fragmentSubpath,
+            packageDirectory,
+            extensionOptions,
+            host,
+            keys,
+            (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
+            comparePatternKeys
+          );
+          return true;
+        }
+        return false;
+      };
+      const shouldCheckExports = fragmentDirectory && getResolvePackageJsonExports(compilerOptions);
+      if (shouldCheckExports) {
         const nodeModulesDirectoryLookup = ancestorLookup;
         ancestorLookup = (ancestor) => {
           const components = getPathComponents(fragment);
@@ -152342,32 +152580,52 @@ function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, c
           const packageDirectory = combinePaths(ancestor, "node_modules", packagePath);
           const packageFile = combinePaths(packageDirectory, "package.json");
           if (tryFileExists(host, packageFile)) {
-            const packageJson = readJson(packageFile, host);
-            const exports = packageJson.exports;
-            if (exports) {
-              if (typeof exports !== "object" || exports === null) {
-                return;
+            const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
+            if (checkExports(packageFile, packageDirectory, fragmentSubpath)) {
+              return;
+            }
+          }
+          return nodeModulesDirectoryLookup(ancestor);
+        };
+      }
+      const pnpApi = getPnpApi(scriptPath);
+      if (pnpApi) {
+        const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+        const dependencyNameMatch = fragment.match(pathRegExp);
+        if (dependencyNameMatch) {
+          const [, dependencyName, subPath] = dependencyNameMatch;
+          let unqualified;
+          try {
+            unqualified = pnpApi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+          } catch (e) {
+          }
+          if (unqualified) {
+            const packageDirectory = normalizePath(unqualified);
+            let shouldGetCompletions = true;
+            if (shouldCheckExports) {
+              const packageFile = combinePaths(packageDirectory, "package.json");
+              if (tryFileExists(host, packageFile) && checkExports(packageFile, packageDirectory, subPath)) {
+                shouldGetCompletions = false;
               }
-              const keys = getOwnKeys(exports);
-              const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
-              const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
-              addCompletionEntriesFromPathsOrExports(
-                result,
-                fragmentSubpath,
+            }
+            if (shouldGetCompletions) {
+              getCompletionEntriesForDirectoryFragment(
+                subPath,
                 packageDirectory,
                 extensionOptions,
                 host,
-                keys,
-                (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
-                comparePatternKeys
+                /*moduleSpecifierIsRelative*/
+                false,
+                /*exclude*/
+                void 0,
+                result
               );
-              return;
             }
           }
-          return nodeModulesDirectoryLookup(ancestor);
-        };
+        }
+      } else {
+        forEachAncestorDirectory(scriptPath, ancestorLookup);
       }
-      forEachAncestorDirectory(scriptPath, ancestorLookup);
     }
   }
   return arrayFrom(result.values());
@@ -152494,9 +152752,15 @@ function getCompletionEntriesFromTypings(host, options, scriptPath, fragmentDire
   for (const root of typeRoots) {
     getCompletionEntriesFromDirectories(root);
   }
-  for (const packageJson of findPackageJsons(scriptPath, host)) {
-    const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
-    getCompletionEntriesFromDirectories(typesDir);
+  if (getPnpApi(scriptPath)) {
+    for (const root of getPnpTypeRoots(scriptPath)) {
+      getCompletionEntriesFromDirectories(root);
+    }
+  } else {
+    for (const packageJson of findPackageJsons(scriptPath, host)) {
+      const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
+      getCompletionEntriesFromDirectories(typesDir);
+    }
   }
   return result;
   function getCompletionEntriesFromDirectories(directory) {
@@ -173223,6 +173487,29 @@ var ConfiguredProject2 = class extends Project3 {
     return this.projectReferences;
   }
   updateReferences(refs) {
+    if (typeof process.versions.pnp !== `undefined`) {
+      const basePath = this.getCurrentDirectory();
+      const getPnpPath = (path) => {
+        try {
+          const pnpApi = getPnpApi(`${path}/`);
+          if (!pnpApi) {
+            return path;
+          }
+          const targetLocator = pnpApi.findPackageLocator(`${path}/`);
+          const { packageLocation } = pnpApi.getPackageInformation(targetLocator);
+          const request = combinePaths(targetLocator.name, getRelativePathFromDirectory(
+            packageLocation,
+            path,
+            /*ignoreCase*/
+            false
+          ));
+          return pnpApi.resolveToUnqualified(request, `${basePath}/`);
+        } catch (e) {
+          return path;
+        }
+      };
+      refs = refs == null ? void 0 : refs.map((r) => ({ ...r, path: getPnpPath(r.path) }));
+    }
     this.projectReferences = refs;
     this.potentialProjectReferences = void 0;
   }
@@ -173794,6 +174081,7 @@ var _ProjectService = class {
       watchFile: returnNoopFileWatcher,
       watchDirectory: returnNoopFileWatcher
     } : getWatchFactory(this.host, watchLogLevel, log, getDetailWatchInfo);
+    this.pnpWatcher = this.watchPnpFile();
   }
   toPath(fileName) {
     return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
@@ -175591,7 +175879,7 @@ Dynamic files must always be opened with service's current directory or service
     this.performanceEventHandler = performanceEventHandler;
   }
   setHostConfiguration(args) {
-    var _a2;
+    var _a2, _b;
     if (args.file) {
       const info = this.getScriptInfoForNormalizedPath(toNormalizedPath(args.file));
       if (info) {
@@ -175635,6 +175923,8 @@ Dynamic files must always be opened with service's current directory or service
       if (args.watchOptions) {
         this.hostConfiguration.watchOptions = (_a2 = convertWatchOptions(args.watchOptions)) == null ? void 0 : _a2.watchOptions;
         this.logger.info(`Host watch options changed to ${JSON.stringify(this.hostConfiguration.watchOptions)}, it will be take effect for next watches.`);
+        (_b = this.pnpWatcher) == null ? void 0 : _b.close();
+        this.watchPnpFile();
       }
     }
   }
@@ -176547,6 +176837,29 @@ Dynamic files must always be opened with service's current directory or service
     });
   }
   /** @internal */
+  watchPnpFile() {
+    const pnpApiPath = getPnpApiPath(__filename);
+    if (!pnpApiPath) {
+      return;
+    }
+    return this.watchFactory.watchFile(
+      pnpApiPath,
+      () => {
+        this.forEachProject((project) => {
+          for (const info of project.getScriptInfos()) {
+            project.resolutionCache.invalidateResolutionOfFile(info.path);
+          }
+          project.markAsDirty();
+          updateProjectIfDirty(project);
+        });
+        this.delayEnsureProjectForOpenFiles();
+      },
+      250 /* Low */,
+      this.hostConfiguration.watchOptions,
+      WatchType.ConfigFile
+    );
+  }
+  /** @internal */
   watchPackageJsonFile(path) {
     const watchers = this.packageJsonFilesMap || (this.packageJsonFilesMap = /* @__PURE__ */ new Map());
     if (!watchers.has(path)) {
@@ -181064,6 +181377,10 @@ function initializeNodeSystem() {
         }
         try {
           const args = [combinePaths(libDirectory, "watchGuard.js"), path];
+          const pnpApiPath = getPnpApiPath(__filename);
+          if (pnpApiPath) {
+            args.unshift("-r", pnpApiPath);
+          }
           if (logger.hasLevel(3 /* verbose */)) {
             logger.info(`Starting ${process.execPath} with args:${stringifyIndented(args)}`);
           }
@@ -181276,6 +181593,10 @@ function startNodeSession(options, logger, cancellationToken) {
           break;
         }
       }
+      const pnpApiPath = getPnpApiPath(__filename);
+      if (pnpApiPath) {
+        execArgv.unshift("-r", pnpApiPath);
+      }
       const typingsInstaller = combinePaths(getDirectoryPath(sys.getExecutingFilePath()), "typingsInstaller.js");
       this.installer = childProcess.fork(typingsInstaller, args, { execArgv });
       this.installer.on("message", (m) => this.handleMessage(m));
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index a69e846e7..d1973b29c 100644
semver exclusivity >=5.0.1-rc <5.1.0-beta
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -6412,6 +6412,9 @@ ${lanes.join("\n")}
             return Buffer2.from && Buffer2.from !== Int8Array.from ? Buffer2.from(input, encoding) : new Buffer2(input, encoding);
           }
           function isFileSystemCaseSensitive() {
+            if (typeof process.versions.pnp !== `undefined`) {
+              return true;
+            }
             if (platform === "win32" || platform === "win64") {
               return false;
             }
@@ -38650,6 +38653,73 @@ ${lanes.join("\n")}
     }
   });
 
+  // src/compiler/pnp.ts
+  function getPnpApi(path) {
+    if (typeof process.versions.pnp === "undefined") {
+      return;
+    }
+    const { findPnpApi } =   require("module");
+    if (findPnpApi) {
+      return findPnpApi(`${path}/`);
+    }
+  }
+  function getPnpApiPath(path) {
+    var _a2;
+    return (_a2 = getPnpApi(path)) == null ? void 0 : _a2.resolveRequest(
+      "pnpapi",
+      /*issuer*/
+      null
+    );
+  }
+  function getPnpTypeRoots(currentDirectory) {
+    const pnpApi = getPnpApi(currentDirectory);
+    if (!pnpApi) {
+      return [];
+    }
+    currentDirectory = resolvePath(currentDirectory);
+    const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+    if (!currentPackage) {
+      return [];
+    }
+    const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+    const typeRoots = [];
+    for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+      if (name.startsWith(`@types/`) && referencish !== null) {
+        const dependencyLocator = pnpApi.getLocator(name, referencish);
+        const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+        typeRoots.push(getDirectoryPath(packageLocation));
+      }
+    }
+    return typeRoots;
+  }
+  function isImportablePathPnp(fromPath, toPath3) {
+    const pnpApi = getPnpApi(fromPath);
+    const fromLocator = pnpApi.findPackageLocator(fromPath);
+    const toLocator = pnpApi.findPackageLocator(toPath3);
+    if (toLocator === null) {
+      return false;
+    }
+    const fromInfo = pnpApi.getPackageInformation(fromLocator);
+    const toReference = fromInfo.packageDependencies.get(toLocator.name);
+    if (toReference) {
+      return toReference === toLocator.reference;
+    }
+    for (const reference of fromInfo.packageDependencies.values()) {
+      if (Array.isArray(reference)) {
+        if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+  var init_pnp = __esm({
+    "src/compiler/pnp.ts"() {
+      "use strict";
+      init_path();
+    }
+  });
+
   // src/compiler/moduleNameResolver.ts
   function trace(host) {
     host.trace(formatMessage.apply(void 0, arguments));
@@ -38859,7 +38929,7 @@ ${lanes.join("\n")}
       return getDefaultTypeRoots(currentDirectory, host);
     }
   }
-  function getDefaultTypeRoots(currentDirectory, host) {
+  function getNodeModulesTypeRoots(currentDirectory, host) {
     if (!host.directoryExists) {
       return [combinePaths(currentDirectory, nodeModulesAtTypes)];
     }
@@ -38877,6 +38947,15 @@ ${lanes.join("\n")}
     const useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
     return comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* EqualTo */;
   }
+  function getDefaultTypeRoots(currentDirectory, host) {
+    const nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+    const pnpTypes = getPnpTypeRoots(currentDirectory);
+    if (nmTypes == null ? void 0 : nmTypes.length) {
+      return [...nmTypes, ...pnpTypes];
+    } else if (pnpTypes.length) {
+      return pnpTypes;
+    }
+  }
   function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
     const resolvedFileName = realPath(fileName, host, traceEnabled);
     const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -39101,6 +39180,21 @@ ${lanes.join("\n")}
   }
   function resolvePackageNameToPackageJson(packageName, containingDirectory, options, host, cache) {
     const moduleResolutionState = getTemporaryModuleResolutionState(cache == null ? void 0 : cache.getPackageJsonInfoCache(), host, options);
+    const pnpapi = getPnpApi(containingDirectory);
+    if (pnpapi) {
+      try {
+        const resolution = pnpapi.resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+        const candidate = normalizeSlashes(resolution).replace(/\/$/, "");
+        return getPackageJsonInfo(
+          candidate,
+          /*onlyRecordFailures*/
+          false,
+          moduleResolutionState
+        );
+      } catch (e) {
+        return;
+      }
+    }
     return forEachAncestorDirectory(containingDirectory, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const nodeModulesFolder = combinePaths(ancestorDirectory, "node_modules");
@@ -40838,7 +40932,15 @@ ${lanes.join("\n")}
       return lookup(secondaryExtensions);
     }
     function lookup(extensions2) {
-      return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+      const issuer = normalizeSlashes(directory);
+      if (getPnpApi(issuer)) {
+        const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+        if (resolutionFromCache) {
+          return resolutionFromCache;
+        }
+        return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+      }
+      return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
         if (getBaseFileName(ancestorDirectory) !== "node_modules") {
           const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
           if (resolutionFromCache) {
@@ -40873,11 +40975,40 @@ ${lanes.join("\n")}
       return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
     }
   }
+  function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+    const issuer = normalizeSlashes(directory);
+    if (!typesScopeOnly) {
+      const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+      if (packageResult) {
+        return packageResult;
+      }
+    }
+    if (extensions & 4 /* Declaration */) {
+      return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+    }
+  }
   function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-    var _a2, _b, _c;
     const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
     const { packageName, rest } = parsePackageName(moduleName);
     const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+    return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+  }
+  function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+    const candidate = normalizePath(combinePaths(packageDirectory, rest));
+    return loadModuleFromSpecificNodeModulesDirectoryImpl(
+      extensions,
+      /*nodeModulesDirectoryExists*/
+      true,
+      state,
+      cache,
+      redirectedReference,
+      candidate,
+      rest,
+      packageDirectory
+    );
+  }
+  function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+    var _a2, _b, _c;
     let rootPackageInfo;
     let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
     if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty((_b = (_a2 = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a2.contents.packageJsonContent) != null ? _b : emptyArray, "exports"))) {
@@ -41143,11 +41274,24 @@ ${lanes.join("\n")}
       trace(state.host, diagnostic, ...args);
     }
   }
+  function loadPnpPackageResolution(packageName, containingDirectory) {
+    try {
+      const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+      return normalizeSlashes(resolution).replace(/\/$/, "");
+    } catch (e) {
+    }
+  }
+  function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+    const { packageName, rest } = parsePackageName(moduleName);
+    const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+    return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+  }
   var typeScriptVersion, nodeModulesAtTypes, NodeResolutionFeatures, nodeModulesPathPart, mangledScopedPackageSeparator;
   var init_moduleNameResolver = __esm({
     "src/compiler/moduleNameResolver.ts"() {
       "use strict";
       init_ts2();
+      init_pnp();
       nodeModulesAtTypes = combinePaths("node_modules", "@types");
       NodeResolutionFeatures = /* @__PURE__ */ ((NodeResolutionFeatures2) => {
         NodeResolutionFeatures2[NodeResolutionFeatures2["None"] = 0] = "None";
@@ -44546,7 +44690,15 @@ ${lanes.join("\n")}
       /*preferSymlinks*/
       true,
       (path, isRedirect) => {
-        const isInNodeModules = pathContainsNodeModules(path);
+        let isInNodeModules = pathContainsNodeModules(path);
+        const pnpapi = getPnpApi(path);
+        if (!isInNodeModules && pnpapi) {
+          const fromLocator = pnpapi.findPackageLocator(importingFileName);
+          const toLocator = pnpapi.findPackageLocator(path);
+          if (fromLocator && toLocator && fromLocator !== toLocator) {
+            isInNodeModules = true;
+          }
+        }
         allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect, isInNodeModules });
         importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
       }
@@ -44738,7 +44890,41 @@ ${lanes.join("\n")}
     if (!host.fileExists || !host.readFile) {
       return void 0;
     }
-    const parts = getNodeModulePathParts(path);
+    let parts = getNodeModulePathParts(path);
+    let pnpPackageName;
+    const pnpApi = getPnpApi(path);
+    if (pnpApi) {
+      const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+      const toLocator = pnpApi.findPackageLocator(path);
+      if (fromLocator === toLocator) {
+        return void 0;
+      }
+      if (fromLocator && toLocator) {
+        const fromInfo = pnpApi.getPackageInformation(fromLocator);
+        if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+          pnpPackageName = toLocator.name;
+        } else {
+          for (const [name, reference] of fromInfo.packageDependencies) {
+            if (Array.isArray(reference)) {
+              if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+                pnpPackageName = name;
+                break;
+              }
+            }
+          }
+        }
+        if (!parts) {
+          const toInfo = pnpApi.getPackageInformation(toLocator);
+          parts = {
+            topLevelNodeModulesIndex: void 0,
+            topLevelPackageNameIndex: void 0,
+            // The last character from packageLocation is the trailing "/", we want to point to it
+            packageRootIndex: toInfo.packageLocation.length - 1,
+            fileNameIndex: path.lastIndexOf(`/`)
+          };
+        }
+      }
+    }
     if (!parts) {
       return void 0;
     }
@@ -44776,14 +44962,16 @@ ${lanes.join("\n")}
     if (isRedirect && !isPackageRootPath) {
       return void 0;
     }
-    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-    if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-      return void 0;
+    if (typeof process.versions.pnp === "undefined") {
+      const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+      const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+      if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+        return void 0;
+      }
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-    const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-    return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+    const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+    return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
     function tryDirectoryWithPackageJson(packageRootIndex) {
       var _a2, _b;
       const packageRootPath = path.substring(0, packageRootIndex);
@@ -44796,9 +44984,9 @@ ${lanes.join("\n")}
         const importMode = overrideMode || importingSourceFile.impliedNodeFormat;
         if (getResolvePackageJsonExports(options)) {
           const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-          const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+          const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
           const conditions = getConditions(options, importMode === 99 /* ESNext */);
-          const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+          const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
           if (fromExports) {
             const withJsExtension = !hasTSFileExtension(fromExports.moduleFileToTry) ? fromExports : { moduleFileToTry: removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
             return { ...withJsExtension, verbatimFromExports: true };
@@ -44945,6 +45133,7 @@ ${lanes.join("\n")}
     "src/compiler/moduleSpecifiers.ts"() {
       "use strict";
       init_ts2();
+      init_pnp();
     }
   });
 
@@ -115099,6 +115288,7 @@ ${lanes.join("\n")}
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["None"] = 0] = "None";
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Partial"] = 1] = "Partial";
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Full"] = 2] = "Full";
+        ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Resolutions"] = 3] = "Resolutions";
         return ConfigFileProgramReloadLevel2;
       })(ConfigFileProgramReloadLevel || {});
       WatchLogLevel = /* @__PURE__ */ ((WatchLogLevel2) => {
@@ -122394,6 +122584,11 @@ ${lanes.join("\n")}
     if (configFileName) {
       configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
     }
+    let pnpFileWatcher;
+    const pnpApiPath = getPnpApiPath(__filename);
+    if (pnpApiPath) {
+      pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+    }
     const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
     setGetSourceFileAsHashVersioned(compilerHost);
     const getNewSourceFile = compilerHost.getSourceFile;
@@ -122455,6 +122650,10 @@ ${lanes.join("\n")}
         configFileWatcher.close();
         configFileWatcher = void 0;
       }
+      if (pnpFileWatcher) {
+        pnpFileWatcher.close();
+        pnpFileWatcher = void 0;
+      }
       extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
       extendedConfigCache = void 0;
       if (sharedExtendedConfigFileWatchers) {
@@ -122487,7 +122686,7 @@ ${lanes.join("\n")}
     function getCurrentProgram() {
       return builderProgram && builderProgram.getProgramOrUndefined();
     }
-    function synchronizeProgram() {
+    function synchronizeProgram(forceAllFilesAsInvalidated = false) {
       writeLog(`Synchronizing program`);
       Debug.assert(compilerOptions);
       Debug.assert(rootFileNames);
@@ -122499,7 +122698,7 @@ ${lanes.join("\n")}
           resolutionCache.clear();
         }
       }
-      const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+      const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions);
       const {
         originalReadFile,
         originalFileExists,
@@ -122705,6 +122904,12 @@ ${lanes.join("\n")}
       reloadLevel = 2 /* Full */;
       scheduleProgramUpdate();
     }
+    function scheduleResolutionReload() {
+      writeLog("Clearing resolutions");
+      resolutionCache.clear();
+      reloadLevel = 3 /* Resolutions */;
+      scheduleProgramUpdate();
+    }
     function updateProgramWithWatchStatus() {
       timerToUpdateProgram = void 0;
       reportFileChangeDetectedOnCreateProgram = true;
@@ -122720,6 +122925,13 @@ ${lanes.join("\n")}
           perfLogger.logStartUpdateProgram("FullConfigReload");
           reloadConfigFile();
           break;
+        case 3 /* Resolutions */:
+          perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+          synchronizeProgram(
+            /*forceAllFilesAsInvalidated*/
+            true
+          );
+          break;
         default:
           perfLogger.logStartUpdateProgram("SynchronizeProgram");
           synchronizeProgram();
@@ -123013,6 +123225,7 @@ ${lanes.join("\n")}
       "use strict";
       init_ts2();
       init_ts2();
+      init_pnp();
     }
   });
 
@@ -128272,7 +128485,14 @@ ${lanes.join("\n")}
       return false;
     }
     function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
-      if (!stringContains(importedFileName, "node_modules")) {
+      const pnpapi = getPnpApi(importedFileName);
+      if (pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(fromFile.fileName);
+        const toLocator = pnpapi.findPackageLocator(importedFileName);
+        if (!(fromLocator && toLocator)) {
+          return void 0;
+        }
+      } else if (!stringContains(importedFileName, "node_modules")) {
         return void 0;
       }
       const specifier = ts_moduleSpecifiers_exports.getNodeModulesPackageName(
@@ -128534,6 +128754,7 @@ ${lanes.join("\n")}
   var init_utilities4 = __esm({
     "src/services/utilities.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       scanner = createScanner(
         99 /* Latest */,
@@ -128805,6 +129026,9 @@ ${lanes.join("\n")}
     return hasImportablePath;
   }
   function isImportablePath(fromPath, toPath3, getCanonicalFileName, globalCachePath) {
+    if (getPnpApi(fromPath)) {
+      return isImportablePathPnp(fromPath, toPath3);
+    }
     const toNodeModules = forEachAncestorDirectory(toPath3, (ancestor) => getBaseFileName(ancestor) === "node_modules" ? ancestor : void 0);
     const toNodeModulesParent = toNodeModules && getDirectoryPath(getCanonicalFileName(toNodeModules));
     return toNodeModulesParent === void 0 || startsWith(getCanonicalFileName(fromPath), toNodeModulesParent) || !!globalCachePath && startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent);
@@ -128988,6 +129212,7 @@ ${lanes.join("\n")}
   var init_exportInfoMap = __esm({
     "src/services/exportInfoMap.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       ImportKind = /* @__PURE__ */ ((ImportKind2) => {
         ImportKind2[ImportKind2["Named"] = 0] = "Named";
@@ -151418,7 +151643,31 @@ ${lanes.join("\n")}
             );
           }
         };
-        if (fragmentDirectory && getResolvePackageJsonExports(compilerOptions)) {
+        const checkExports = (packageFile, packageDirectory, fragmentSubpath) => {
+          const packageJson = readJson(packageFile, host);
+          const exports = packageJson.exports;
+          if (exports) {
+            if (typeof exports !== "object" || exports === null) {
+              return true;
+            }
+            const keys = getOwnKeys(exports);
+            const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
+            addCompletionEntriesFromPathsOrExports(
+              result,
+              fragmentSubpath,
+              packageDirectory,
+              extensionOptions,
+              host,
+              keys,
+              (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
+              comparePatternKeys
+            );
+            return true;
+          }
+          return false;
+        };
+        const shouldCheckExports = fragmentDirectory && getResolvePackageJsonExports(compilerOptions);
+        if (shouldCheckExports) {
           const nodeModulesDirectoryLookup = ancestorLookup;
           ancestorLookup = (ancestor) => {
             const components = getPathComponents(fragment);
@@ -151437,32 +151686,52 @@ ${lanes.join("\n")}
             const packageDirectory = combinePaths(ancestor, "node_modules", packagePath);
             const packageFile = combinePaths(packageDirectory, "package.json");
             if (tryFileExists(host, packageFile)) {
-              const packageJson = readJson(packageFile, host);
-              const exports = packageJson.exports;
-              if (exports) {
-                if (typeof exports !== "object" || exports === null) {
-                  return;
+              const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
+              if (checkExports(packageFile, packageDirectory, fragmentSubpath)) {
+                return;
+              }
+            }
+            return nodeModulesDirectoryLookup(ancestor);
+          };
+        }
+        const pnpApi = getPnpApi(scriptPath);
+        if (pnpApi) {
+          const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+          const dependencyNameMatch = fragment.match(pathRegExp);
+          if (dependencyNameMatch) {
+            const [, dependencyName, subPath] = dependencyNameMatch;
+            let unqualified;
+            try {
+              unqualified = pnpApi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+            } catch (e) {
+            }
+            if (unqualified) {
+              const packageDirectory = normalizePath(unqualified);
+              let shouldGetCompletions = true;
+              if (shouldCheckExports) {
+                const packageFile = combinePaths(packageDirectory, "package.json");
+                if (tryFileExists(host, packageFile) && checkExports(packageFile, packageDirectory, subPath)) {
+                  shouldGetCompletions = false;
                 }
-                const keys = getOwnKeys(exports);
-                const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
-                addCompletionEntriesFromPathsOrExports(
-                  result,
-                  fragmentSubpath,
+              }
+              if (shouldGetCompletions) {
+                getCompletionEntriesForDirectoryFragment(
+                  subPath,
                   packageDirectory,
                   extensionOptions,
                   host,
-                  keys,
-                  (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
-                  comparePatternKeys
+                  /*moduleSpecifierIsRelative*/
+                  false,
+                  /*exclude*/
+                  void 0,
+                  result
                 );
-                return;
               }
             }
-            return nodeModulesDirectoryLookup(ancestor);
-          };
+          }
+        } else {
+          forEachAncestorDirectory(scriptPath, ancestorLookup);
         }
-        forEachAncestorDirectory(scriptPath, ancestorLookup);
       }
     }
     return arrayFrom(result.values());
@@ -151589,9 +151858,15 @@ ${lanes.join("\n")}
     for (const root of typeRoots) {
       getCompletionEntriesFromDirectories(root);
     }
-    for (const packageJson of findPackageJsons(scriptPath, host)) {
-      const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
-      getCompletionEntriesFromDirectories(typesDir);
+    if (getPnpApi(scriptPath)) {
+      for (const root of getPnpTypeRoots(scriptPath)) {
+        getCompletionEntriesFromDirectories(root);
+      }
+    } else {
+      for (const packageJson of findPackageJsons(scriptPath, host)) {
+        const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
+        getCompletionEntriesFromDirectories(typesDir);
+      }
     }
     return result;
     function getCompletionEntriesFromDirectories(directory) {
@@ -151674,6 +151949,7 @@ ${lanes.join("\n")}
   var init_stringCompletions = __esm({
     "src/services/stringCompletions.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       init_ts_Completions();
       kindPrecedence = {
@@ -168594,6 +168870,7 @@ ${options.prefix}` : "\n" : options.prefix
   var init_project = __esm({
     "src/server/project.ts"() {
       "use strict";
+      init_pnp();
       init_ts6();
       init_ts6();
       init_ts_server2();
@@ -170556,6 +170833,29 @@ ${options.prefix}` : "\n" : options.prefix
           return this.projectReferences;
         }
         updateReferences(refs) {
+          if (typeof process.versions.pnp !== `undefined`) {
+            const basePath = this.getCurrentDirectory();
+            const getPnpPath = (path) => {
+              try {
+                const pnpApi = getPnpApi(`${path}/`);
+                if (!pnpApi) {
+                  return path;
+                }
+                const targetLocator = pnpApi.findPackageLocator(`${path}/`);
+                const { packageLocation } = pnpApi.getPackageInformation(targetLocator);
+                const request = combinePaths(targetLocator.name, getRelativePathFromDirectory(
+                  packageLocation,
+                  path,
+                  /*ignoreCase*/
+                  false
+                ));
+                return pnpApi.resolveToUnqualified(request, `${basePath}/`);
+              } catch (e) {
+                return path;
+              }
+            };
+            refs = refs == null ? void 0 : refs.map((r) => ({ ...r, path: getPnpPath(r.path) }));
+          }
           this.projectReferences = refs;
           this.potentialProjectReferences = void 0;
         }
@@ -170936,6 +171236,7 @@ ${options.prefix}` : "\n" : options.prefix
   var init_editorServices = __esm({
     "src/server/editorServices.ts"() {
       "use strict";
+      init_pnp();
       init_ts6();
       init_ts_server2();
       maxProgramSizeForNonTsFiles = 20 * 1024 * 1024;
@@ -171149,6 +171450,7 @@ ${options.prefix}` : "\n" : options.prefix
             watchFile: returnNoopFileWatcher,
             watchDirectory: returnNoopFileWatcher
           } : getWatchFactory(this.host, watchLogLevel, log, getDetailWatchInfo);
+          this.pnpWatcher = this.watchPnpFile();
         }
         toPath(fileName) {
           return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
@@ -172946,7 +173248,7 @@ Dynamic files must always be opened with service's current directory or service
           this.performanceEventHandler = performanceEventHandler;
         }
         setHostConfiguration(args) {
-          var _a2;
+          var _a2, _b;
           if (args.file) {
             const info = this.getScriptInfoForNormalizedPath(toNormalizedPath(args.file));
             if (info) {
@@ -172990,6 +173292,8 @@ Dynamic files must always be opened with service's current directory or service
             if (args.watchOptions) {
               this.hostConfiguration.watchOptions = (_a2 = convertWatchOptions(args.watchOptions)) == null ? void 0 : _a2.watchOptions;
               this.logger.info(`Host watch options changed to ${JSON.stringify(this.hostConfiguration.watchOptions)}, it will be take effect for next watches.`);
+              (_b = this.pnpWatcher) == null ? void 0 : _b.close();
+              this.watchPnpFile();
             }
           }
         }
@@ -173902,6 +174206,29 @@ Dynamic files must always be opened with service's current directory or service
           });
         }
         /** @internal */
+        watchPnpFile() {
+          const pnpApiPath = getPnpApiPath(__filename);
+          if (!pnpApiPath) {
+            return;
+          }
+          return this.watchFactory.watchFile(
+            pnpApiPath,
+            () => {
+              this.forEachProject((project) => {
+                for (const info of project.getScriptInfos()) {
+                  project.resolutionCache.invalidateResolutionOfFile(info.path);
+                }
+                project.markAsDirty();
+                updateProjectIfDirty(project);
+              });
+              this.delayEnsureProjectForOpenFiles();
+            },
+            250 /* Low */,
+            this.hostConfiguration.watchOptions,
+            WatchType.ConfigFile
+          );
+        }
+        /** @internal */
         watchPackageJsonFile(path) {
           const watchers = this.packageJsonFilesMap || (this.packageJsonFilesMap = /* @__PURE__ */ new Map());
           if (!watchers.has(path)) {
diff --git a/lib/typescript.js b/lib/typescript.js
index 4b53c156e..54d44a8d6 100644
semver exclusivity >=5.0.1-rc <5.1.0-beta
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -6412,6 +6412,9 @@ ${lanes.join("\n")}
             return Buffer2.from && Buffer2.from !== Int8Array.from ? Buffer2.from(input, encoding) : new Buffer2(input, encoding);
           }
           function isFileSystemCaseSensitive() {
+            if (typeof process.versions.pnp !== `undefined`) {
+              return true;
+            }
             if (platform === "win32" || platform === "win64") {
               return false;
             }
@@ -38650,6 +38653,73 @@ ${lanes.join("\n")}
     }
   });
 
+  // src/compiler/pnp.ts
+  function getPnpApi(path) {
+    if (typeof process.versions.pnp === "undefined") {
+      return;
+    }
+    const { findPnpApi } =   require("module");
+    if (findPnpApi) {
+      return findPnpApi(`${path}/`);
+    }
+  }
+  function getPnpApiPath(path) {
+    var _a2;
+    return (_a2 = getPnpApi(path)) == null ? void 0 : _a2.resolveRequest(
+      "pnpapi",
+      /*issuer*/
+      null
+    );
+  }
+  function getPnpTypeRoots(currentDirectory) {
+    const pnpApi = getPnpApi(currentDirectory);
+    if (!pnpApi) {
+      return [];
+    }
+    currentDirectory = resolvePath(currentDirectory);
+    const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+    if (!currentPackage) {
+      return [];
+    }
+    const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+    const typeRoots = [];
+    for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+      if (name.startsWith(`@types/`) && referencish !== null) {
+        const dependencyLocator = pnpApi.getLocator(name, referencish);
+        const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+        typeRoots.push(getDirectoryPath(packageLocation));
+      }
+    }
+    return typeRoots;
+  }
+  function isImportablePathPnp(fromPath, toPath3) {
+    const pnpApi = getPnpApi(fromPath);
+    const fromLocator = pnpApi.findPackageLocator(fromPath);
+    const toLocator = pnpApi.findPackageLocator(toPath3);
+    if (toLocator === null) {
+      return false;
+    }
+    const fromInfo = pnpApi.getPackageInformation(fromLocator);
+    const toReference = fromInfo.packageDependencies.get(toLocator.name);
+    if (toReference) {
+      return toReference === toLocator.reference;
+    }
+    for (const reference of fromInfo.packageDependencies.values()) {
+      if (Array.isArray(reference)) {
+        if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+  var init_pnp = __esm({
+    "src/compiler/pnp.ts"() {
+      "use strict";
+      init_path();
+    }
+  });
+
   // src/compiler/moduleNameResolver.ts
   function trace(host) {
     host.trace(formatMessage.apply(void 0, arguments));
@@ -38859,7 +38929,7 @@ ${lanes.join("\n")}
       return getDefaultTypeRoots(currentDirectory, host);
     }
   }
-  function getDefaultTypeRoots(currentDirectory, host) {
+  function getNodeModulesTypeRoots(currentDirectory, host) {
     if (!host.directoryExists) {
       return [combinePaths(currentDirectory, nodeModulesAtTypes)];
     }
@@ -38877,6 +38947,15 @@ ${lanes.join("\n")}
     const useCaseSensitiveFileNames = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
     return comparePaths(path1, path2, !useCaseSensitiveFileNames) === 0 /* EqualTo */;
   }
+  function getDefaultTypeRoots(currentDirectory, host) {
+    const nmTypes = getNodeModulesTypeRoots(currentDirectory, host);
+    const pnpTypes = getPnpTypeRoots(currentDirectory);
+    if (nmTypes == null ? void 0 : nmTypes.length) {
+      return [...nmTypes, ...pnpTypes];
+    } else if (pnpTypes.length) {
+      return pnpTypes;
+    }
+  }
   function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
     const resolvedFileName = realPath(fileName, host, traceEnabled);
     const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -39101,6 +39180,21 @@ ${lanes.join("\n")}
   }
   function resolvePackageNameToPackageJson(packageName, containingDirectory, options, host, cache) {
     const moduleResolutionState = getTemporaryModuleResolutionState(cache == null ? void 0 : cache.getPackageJsonInfoCache(), host, options);
+    const pnpapi = getPnpApi(containingDirectory);
+    if (pnpapi) {
+      try {
+        const resolution = pnpapi.resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+        const candidate = normalizeSlashes(resolution).replace(/\/$/, "");
+        return getPackageJsonInfo(
+          candidate,
+          /*onlyRecordFailures*/
+          false,
+          moduleResolutionState
+        );
+      } catch (e) {
+        return;
+      }
+    }
     return forEachAncestorDirectory(containingDirectory, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const nodeModulesFolder = combinePaths(ancestorDirectory, "node_modules");
@@ -40838,7 +40932,15 @@ ${lanes.join("\n")}
       return lookup(secondaryExtensions);
     }
     function lookup(extensions2) {
-      return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+      const issuer = normalizeSlashes(directory);
+      if (getPnpApi(issuer)) {
+        const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+        if (resolutionFromCache) {
+          return resolutionFromCache;
+        }
+        return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+      }
+      return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
         if (getBaseFileName(ancestorDirectory) !== "node_modules") {
           const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
           if (resolutionFromCache) {
@@ -40873,11 +40975,40 @@ ${lanes.join("\n")}
       return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
     }
   }
+  function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+    const issuer = normalizeSlashes(directory);
+    if (!typesScopeOnly) {
+      const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+      if (packageResult) {
+        return packageResult;
+      }
+    }
+    if (extensions & 4 /* Declaration */) {
+      return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+    }
+  }
   function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-    var _a2, _b, _c;
     const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
     const { packageName, rest } = parsePackageName(moduleName);
     const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+    return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+  }
+  function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+    const candidate = normalizePath(combinePaths(packageDirectory, rest));
+    return loadModuleFromSpecificNodeModulesDirectoryImpl(
+      extensions,
+      /*nodeModulesDirectoryExists*/
+      true,
+      state,
+      cache,
+      redirectedReference,
+      candidate,
+      rest,
+      packageDirectory
+    );
+  }
+  function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+    var _a2, _b, _c;
     let rootPackageInfo;
     let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
     if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty((_b = (_a2 = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a2.contents.packageJsonContent) != null ? _b : emptyArray, "exports"))) {
@@ -41143,11 +41274,24 @@ ${lanes.join("\n")}
       trace(state.host, diagnostic, ...args);
     }
   }
+  function loadPnpPackageResolution(packageName, containingDirectory) {
+    try {
+      const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+      return normalizeSlashes(resolution).replace(/\/$/, "");
+    } catch (e) {
+    }
+  }
+  function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+    const { packageName, rest } = parsePackageName(moduleName);
+    const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+    return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+  }
   var typeScriptVersion, nodeModulesAtTypes, NodeResolutionFeatures, nodeModulesPathPart, mangledScopedPackageSeparator;
   var init_moduleNameResolver = __esm({
     "src/compiler/moduleNameResolver.ts"() {
       "use strict";
       init_ts2();
+      init_pnp();
       nodeModulesAtTypes = combinePaths("node_modules", "@types");
       NodeResolutionFeatures = /* @__PURE__ */ ((NodeResolutionFeatures2) => {
         NodeResolutionFeatures2[NodeResolutionFeatures2["None"] = 0] = "None";
@@ -44546,7 +44690,15 @@ ${lanes.join("\n")}
       /*preferSymlinks*/
       true,
       (path, isRedirect) => {
-        const isInNodeModules = pathContainsNodeModules(path);
+        let isInNodeModules = pathContainsNodeModules(path);
+        const pnpapi = getPnpApi(path);
+        if (!isInNodeModules && pnpapi) {
+          const fromLocator = pnpapi.findPackageLocator(importingFileName);
+          const toLocator = pnpapi.findPackageLocator(path);
+          if (fromLocator && toLocator && fromLocator !== toLocator) {
+            isInNodeModules = true;
+          }
+        }
         allFileNames.set(path, { path: getCanonicalFileName(path), isRedirect, isInNodeModules });
         importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
       }
@@ -44738,7 +44890,41 @@ ${lanes.join("\n")}
     if (!host.fileExists || !host.readFile) {
       return void 0;
     }
-    const parts = getNodeModulePathParts(path);
+    let parts = getNodeModulePathParts(path);
+    let pnpPackageName;
+    const pnpApi = getPnpApi(path);
+    if (pnpApi) {
+      const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+      const toLocator = pnpApi.findPackageLocator(path);
+      if (fromLocator === toLocator) {
+        return void 0;
+      }
+      if (fromLocator && toLocator) {
+        const fromInfo = pnpApi.getPackageInformation(fromLocator);
+        if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+          pnpPackageName = toLocator.name;
+        } else {
+          for (const [name, reference] of fromInfo.packageDependencies) {
+            if (Array.isArray(reference)) {
+              if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+                pnpPackageName = name;
+                break;
+              }
+            }
+          }
+        }
+        if (!parts) {
+          const toInfo = pnpApi.getPackageInformation(toLocator);
+          parts = {
+            topLevelNodeModulesIndex: void 0,
+            topLevelPackageNameIndex: void 0,
+            // The last character from packageLocation is the trailing "/", we want to point to it
+            packageRootIndex: toInfo.packageLocation.length - 1,
+            fileNameIndex: path.lastIndexOf(`/`)
+          };
+        }
+      }
+    }
     if (!parts) {
       return void 0;
     }
@@ -44776,14 +44962,16 @@ ${lanes.join("\n")}
     if (isRedirect && !isPackageRootPath) {
       return void 0;
     }
-    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-    if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-      return void 0;
+    if (typeof process.versions.pnp === "undefined") {
+      const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+      const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+      if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+        return void 0;
+      }
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-    const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-    return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+    const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+    return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
     function tryDirectoryWithPackageJson(packageRootIndex) {
       var _a2, _b;
       const packageRootPath = path.substring(0, packageRootIndex);
@@ -44796,9 +44984,9 @@ ${lanes.join("\n")}
         const importMode = overrideMode || importingSourceFile.impliedNodeFormat;
         if (getResolvePackageJsonExports(options)) {
           const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-          const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+          const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
           const conditions = getConditions(options, importMode === 99 /* ESNext */);
-          const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+          const fromExports = packageJsonContent.exports ? tryGetModuleNameFromExports(options, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
           if (fromExports) {
             const withJsExtension = !hasTSFileExtension(fromExports.moduleFileToTry) ? fromExports : { moduleFileToTry: removeFileExtension(fromExports.moduleFileToTry) + tryGetJSExtensionForFile(fromExports.moduleFileToTry, options) };
             return { ...withJsExtension, verbatimFromExports: true };
@@ -44945,6 +45133,7 @@ ${lanes.join("\n")}
     "src/compiler/moduleSpecifiers.ts"() {
       "use strict";
       init_ts2();
+      init_pnp();
     }
   });
 
@@ -115099,6 +115288,7 @@ ${lanes.join("\n")}
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["None"] = 0] = "None";
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Partial"] = 1] = "Partial";
         ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Full"] = 2] = "Full";
+        ConfigFileProgramReloadLevel2[ConfigFileProgramReloadLevel2["Resolutions"] = 3] = "Resolutions";
         return ConfigFileProgramReloadLevel2;
       })(ConfigFileProgramReloadLevel || {});
       WatchLogLevel = /* @__PURE__ */ ((WatchLogLevel2) => {
@@ -122394,6 +122584,11 @@ ${lanes.join("\n")}
     if (configFileName) {
       configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
     }
+    let pnpFileWatcher;
+    const pnpApiPath = getPnpApiPath(__filename);
+    if (pnpApiPath) {
+      pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+    }
     const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
     setGetSourceFileAsHashVersioned(compilerHost);
     const getNewSourceFile = compilerHost.getSourceFile;
@@ -122455,6 +122650,10 @@ ${lanes.join("\n")}
         configFileWatcher.close();
         configFileWatcher = void 0;
       }
+      if (pnpFileWatcher) {
+        pnpFileWatcher.close();
+        pnpFileWatcher = void 0;
+      }
       extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
       extendedConfigCache = void 0;
       if (sharedExtendedConfigFileWatchers) {
@@ -122487,7 +122686,7 @@ ${lanes.join("\n")}
     function getCurrentProgram() {
       return builderProgram && builderProgram.getProgramOrUndefined();
     }
-    function synchronizeProgram() {
+    function synchronizeProgram(forceAllFilesAsInvalidated = false) {
       writeLog(`Synchronizing program`);
       Debug.assert(compilerOptions);
       Debug.assert(rootFileNames);
@@ -122499,7 +122698,7 @@ ${lanes.join("\n")}
           resolutionCache.clear();
         }
       }
-      const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions);
+      const hasInvalidatedResolutions = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions);
       const {
         originalReadFile,
         originalFileExists,
@@ -122705,6 +122904,12 @@ ${lanes.join("\n")}
       reloadLevel = 2 /* Full */;
       scheduleProgramUpdate();
     }
+    function scheduleResolutionReload() {
+      writeLog("Clearing resolutions");
+      resolutionCache.clear();
+      reloadLevel = 3 /* Resolutions */;
+      scheduleProgramUpdate();
+    }
     function updateProgramWithWatchStatus() {
       timerToUpdateProgram = void 0;
       reportFileChangeDetectedOnCreateProgram = true;
@@ -122720,6 +122925,13 @@ ${lanes.join("\n")}
           perfLogger.logStartUpdateProgram("FullConfigReload");
           reloadConfigFile();
           break;
+        case 3 /* Resolutions */:
+          perfLogger.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+          synchronizeProgram(
+            /*forceAllFilesAsInvalidated*/
+            true
+          );
+          break;
         default:
           perfLogger.logStartUpdateProgram("SynchronizeProgram");
           synchronizeProgram();
@@ -123013,6 +123225,7 @@ ${lanes.join("\n")}
       "use strict";
       init_ts2();
       init_ts2();
+      init_pnp();
     }
   });
 
@@ -128286,7 +128499,14 @@ ${lanes.join("\n")}
       return false;
     }
     function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
-      if (!stringContains(importedFileName, "node_modules")) {
+      const pnpapi = getPnpApi(importedFileName);
+      if (pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(fromFile.fileName);
+        const toLocator = pnpapi.findPackageLocator(importedFileName);
+        if (!(fromLocator && toLocator)) {
+          return void 0;
+        }
+      } else if (!stringContains(importedFileName, "node_modules")) {
         return void 0;
       }
       const specifier = ts_moduleSpecifiers_exports.getNodeModulesPackageName(
@@ -128548,6 +128768,7 @@ ${lanes.join("\n")}
   var init_utilities4 = __esm({
     "src/services/utilities.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       scanner = createScanner(
         99 /* Latest */,
@@ -128819,6 +129040,9 @@ ${lanes.join("\n")}
     return hasImportablePath;
   }
   function isImportablePath(fromPath, toPath3, getCanonicalFileName, globalCachePath) {
+    if (getPnpApi(fromPath)) {
+      return isImportablePathPnp(fromPath, toPath3);
+    }
     const toNodeModules = forEachAncestorDirectory(toPath3, (ancestor) => getBaseFileName(ancestor) === "node_modules" ? ancestor : void 0);
     const toNodeModulesParent = toNodeModules && getDirectoryPath(getCanonicalFileName(toNodeModules));
     return toNodeModulesParent === void 0 || startsWith(getCanonicalFileName(fromPath), toNodeModulesParent) || !!globalCachePath && startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent);
@@ -129002,6 +129226,7 @@ ${lanes.join("\n")}
   var init_exportInfoMap = __esm({
     "src/services/exportInfoMap.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       ImportKind = /* @__PURE__ */ ((ImportKind2) => {
         ImportKind2[ImportKind2["Named"] = 0] = "Named";
@@ -151432,7 +151657,31 @@ ${lanes.join("\n")}
             );
           }
         };
-        if (fragmentDirectory && getResolvePackageJsonExports(compilerOptions)) {
+        const checkExports = (packageFile, packageDirectory, fragmentSubpath) => {
+          const packageJson = readJson(packageFile, host);
+          const exports = packageJson.exports;
+          if (exports) {
+            if (typeof exports !== "object" || exports === null) {
+              return true;
+            }
+            const keys = getOwnKeys(exports);
+            const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
+            addCompletionEntriesFromPathsOrExports(
+              result,
+              fragmentSubpath,
+              packageDirectory,
+              extensionOptions,
+              host,
+              keys,
+              (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
+              comparePatternKeys
+            );
+            return true;
+          }
+          return false;
+        };
+        const shouldCheckExports = fragmentDirectory && getResolvePackageJsonExports(compilerOptions);
+        if (shouldCheckExports) {
           const nodeModulesDirectoryLookup = ancestorLookup;
           ancestorLookup = (ancestor) => {
             const components = getPathComponents(fragment);
@@ -151451,32 +151700,52 @@ ${lanes.join("\n")}
             const packageDirectory = combinePaths(ancestor, "node_modules", packagePath);
             const packageFile = combinePaths(packageDirectory, "package.json");
             if (tryFileExists(host, packageFile)) {
-              const packageJson = readJson(packageFile, host);
-              const exports = packageJson.exports;
-              if (exports) {
-                if (typeof exports !== "object" || exports === null) {
-                  return;
+              const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
+              if (checkExports(packageFile, packageDirectory, fragmentSubpath)) {
+                return;
+              }
+            }
+            return nodeModulesDirectoryLookup(ancestor);
+          };
+        }
+        const pnpApi = getPnpApi(scriptPath);
+        if (pnpApi) {
+          const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+          const dependencyNameMatch = fragment.match(pathRegExp);
+          if (dependencyNameMatch) {
+            const [, dependencyName, subPath] = dependencyNameMatch;
+            let unqualified;
+            try {
+              unqualified = pnpApi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+            } catch (e) {
+            }
+            if (unqualified) {
+              const packageDirectory = normalizePath(unqualified);
+              let shouldGetCompletions = true;
+              if (shouldCheckExports) {
+                const packageFile = combinePaths(packageDirectory, "package.json");
+                if (tryFileExists(host, packageFile) && checkExports(packageFile, packageDirectory, subPath)) {
+                  shouldGetCompletions = false;
                 }
-                const keys = getOwnKeys(exports);
-                const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
-                const conditions = mode === 99 /* ESNext */ ? ["node", "import", "types"] : ["node", "require", "types"];
-                addCompletionEntriesFromPathsOrExports(
-                  result,
-                  fragmentSubpath,
+              }
+              if (shouldGetCompletions) {
+                getCompletionEntriesForDirectoryFragment(
+                  subPath,
                   packageDirectory,
                   extensionOptions,
                   host,
-                  keys,
-                  (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports[key], conditions)),
-                  comparePatternKeys
+                  /*moduleSpecifierIsRelative*/
+                  false,
+                  /*exclude*/
+                  void 0,
+                  result
                 );
-                return;
               }
             }
-            return nodeModulesDirectoryLookup(ancestor);
-          };
+          }
+        } else {
+          forEachAncestorDirectory(scriptPath, ancestorLookup);
         }
-        forEachAncestorDirectory(scriptPath, ancestorLookup);
       }
     }
     return arrayFrom(result.values());
@@ -151603,9 +151872,15 @@ ${lanes.join("\n")}
     for (const root of typeRoots) {
       getCompletionEntriesFromDirectories(root);
     }
-    for (const packageJson of findPackageJsons(scriptPath, host)) {
-      const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
-      getCompletionEntriesFromDirectories(typesDir);
+    if (getPnpApi(scriptPath)) {
+      for (const root of getPnpTypeRoots(scriptPath)) {
+        getCompletionEntriesFromDirectories(root);
+      }
+    } else {
+      for (const packageJson of findPackageJsons(scriptPath, host)) {
+        const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
+        getCompletionEntriesFromDirectories(typesDir);
+      }
     }
     return result;
     function getCompletionEntriesFromDirectories(directory) {
@@ -151688,6 +151963,7 @@ ${lanes.join("\n")}
   var init_stringCompletions = __esm({
     "src/services/stringCompletions.ts"() {
       "use strict";
+      init_pnp();
       init_ts4();
       init_ts_Completions();
       kindPrecedence = {
diff --git a/lib/typingsInstaller.js b/lib/typingsInstaller.js
index 00afe537d..97a3bab6b 100644
semver exclusivity >=5.0.1-rc <5.1.0-beta
--- a/lib/typingsInstaller.js
+++ b/lib/typingsInstaller.js
@@ -4587,6 +4587,9 @@ var sys = (() => {
       return Buffer2.from && Buffer2.from !== Int8Array.from ? Buffer2.from(input, encoding) : new Buffer2(input, encoding);
     }
     function isFileSystemCaseSensitive() {
+      if (typeof process.versions.pnp !== `undefined`) {
+        return true;
+      }
       if (platform === "win32" || platform === "win64") {
         return false;
       }
@@ -27919,6 +27922,17 @@ function specToDiagnostic(spec, disallowTrailingRecursion) {
   }
 }
 
+// src/compiler/pnp.ts
+function getPnpApi(path2) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  const { findPnpApi } = require("module");
+  if (findPnpApi) {
+    return findPnpApi(`${path2}/`);
+  }
+}
+
 // src/compiler/moduleNameResolver.ts
 function trace(host) {
   host.trace(formatMessage.apply(void 0, arguments));
@@ -29383,7 +29397,15 @@ function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName,
     return lookup(secondaryExtensions);
   }
   function lookup(extensions2) {
-    return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+    const issuer = normalizeSlashes(directory);
+    if (getPnpApi(issuer)) {
+      const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+      if (resolutionFromCache) {
+        return resolutionFromCache;
+      }
+      return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+    }
+    return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
         if (resolutionFromCache) {
@@ -29418,11 +29440,40 @@ function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, dir
     return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
   }
 }
+function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+  const issuer = normalizeSlashes(directory);
+  if (!typesScopeOnly) {
+    const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+    if (packageResult) {
+      return packageResult;
+    }
+  }
+  if (extensions & 4 /* Declaration */) {
+    return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+  }
+}
 function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-  var _a2, _b, _c;
   const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
   const { packageName, rest } = parsePackageName(moduleName);
   const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+}
+function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+  const candidate = normalizePath(combinePaths(packageDirectory, rest));
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(
+    extensions,
+    /*nodeModulesDirectoryExists*/
+    true,
+    state,
+    cache,
+    redirectedReference,
+    candidate,
+    rest,
+    packageDirectory
+  );
+}
+function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+  var _a2, _b, _c;
   let rootPackageInfo;
   let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
   if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty((_b = (_a2 = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a2.contents.packageJsonContent) != null ? _b : emptyArray, "exports"))) {
@@ -29629,6 +29680,18 @@ function traceIfEnabled(state, diagnostic, ...args) {
     trace(state.host, diagnostic, ...args);
   }
 }
+function loadPnpPackageResolution(packageName, containingDirectory) {
+  try {
+    const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+    return normalizeSlashes(resolution).replace(/\/$/, "");
+  } catch (e) {
+  }
+}
+function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+  const { packageName, rest } = parsePackageName(moduleName);
+  const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+  return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+}
 
 // src/compiler/binder.ts
 function getModuleInstanceState(node, visited) {
