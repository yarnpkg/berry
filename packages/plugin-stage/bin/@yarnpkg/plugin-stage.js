/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-stage",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var t={454:(t,e,n)=>{n.r(e),n.d(e,{default:()=>w});function a(t,e,n,a){var o,i=arguments.length,r=i<3?e:null===a?a=Object.getOwnPropertyDescriptor(e,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(t,e,n,a);else for(var s=t.length-1;s>=0;s--)(o=t[s])&&(r=(i<3?o(r):i>3?o(e,n,r):o(e,n))||r);return i>3&&r&&Object.defineProperty(e,n,r),r}var o,i=n(594),r=n(966),s=n(688),c=n(42);async function l(t,{marker:e}){do{if(s.xfs.existsSync(s.ppath.join(t,e)))return t;t=s.ppath.dirname(t)}while("/"!==t);return null}function p(t,e){let n=0,a=0;for(const o of t)"wip"!==o&&(e.test(o)?n+=1:a+=1);return n>=a}!function(t){t[t.CREATE=0]="CREATE",t[t.DELETE=1]="DELETE",t[t.ADD=2]="ADD",t[t.REMOVE=3]="REMOVE",t[t.MODIFY=4]="MODIFY"}(o||(o={}));const u=new Map([[o.CREATE,"create"],[o.DELETE,"delete"],[o.ADD,"add"],[o.REMOVE,"remove"],[o.MODIFY,"update"]]);async function d(t){const{code:e,stdout:n}=await r.execUtils.execvp("git",["log","-1","--pretty=format:%H"],{cwd:t});return 0===e?n.trim():null}async function f(t,e){const n=[],a=e.filter(t=>"package.json"===s.ppath.basename(t.path));for(const{action:e,path:i}of a){const a=s.ppath.relative(t,i);if(e===o.MODIFY){const e=await d(t),{stdout:s}=await r.execUtils.execvp("git",["show",`${e}:${a}`],{cwd:t,strict:!0}),c=await r.Manifest.fromText(s),l=await r.Manifest.fromFile(i),p=new Map([...l.dependencies,...l.devDependencies]),u=new Map([...c.dependencies,...c.devDependencies]);for(const[t,e]of u){const a=r.structUtils.stringifyIdent(e),i=p.get(t);i?i.range!==e.range&&n.push([o.MODIFY,`${a} to ${i.range}`]):n.push([o.REMOVE,a])}for(const[t,e]of p)u.has(t)||n.push([o.ADD,r.structUtils.stringifyIdent(e)])}else if(e===o.CREATE){const t=await r.Manifest.fromFile(i);t.name?n.push([o.CREATE,r.structUtils.stringifyIdent(t.name)]):n.push([o.CREATE,"a package"])}else{if(e!==o.DELETE)throw new Error("Assertion failed: Unsupported action type");{const e=await d(t),{stdout:i}=await r.execUtils.execvp("git",["show",`${e}:${a}`],{cwd:t,strict:!0}),s=await r.Manifest.fromText(i);s.name?n.push([o.DELETE,r.structUtils.stringifyIdent(s.name)]):n.push([o.DELETE,"a package"])}}}const{code:i,stdout:c}=await r.execUtils.execvp("git",["log","-11","--pretty=format:%s"],{cwd:t});return function(t,e){const n=function(t){return t.useComponent?"chore(yarn): ":""}(t),a=[],o=e.slice().sort((t,e)=>t[0]-e[0]);for(;o.length>0;){const[e,n]=o.shift();let i=u.get(e);t.useUpperCase&&0===a.length&&(i=`${i[0].toUpperCase()}${i.slice(1)}`),t.useThirdPerson&&(i+="s");const r=[n];for(;o.length>0&&o[0][0]===e;){const[,t]=o.shift();r.push(t)}r.sort();let s=r.shift();1===r.length?s+=" (and one other)":r.length>1&&(s+=` (and ${r.length} others)`),a.push(`${i} ${s}`)}return`${n}${a.join(", ")}`}(function(t){return{useThirdPerson:p(t,/^(\w\(\w+\):\s*)?\w+s/),useUpperCase:p(t,/^(\w\(\w+\):\s*)?[A-Z]/),useComponent:p(t,/^\w\(\w+\):/)}}(0===i?c.split(/\n/g).filter(t=>""!==t):[]),n)}const h=[{findRoot:async t=>await l(t,{marker:(0,s.toFilename)(".git")}),async filterChanges(t,e,n){const{stdout:a}=await r.execUtils.execvp("git",["status","-s"],{cwd:t,strict:!0}),i=a.toString().split(/\n/g);return[].concat(...i.map(e=>{if(""===e)return[];const n=e.slice(0,3),a=s.ppath.resolve(t,e.slice(3));return"?? "===n&&e.endsWith("/")?function(t){const e=[],n=[t];for(;n.length>0;){const t=n.pop(),a=s.xfs.readdirSync(t);for(const o of a){const a=s.ppath.resolve(t,o);s.xfs.lstatSync(a).isDirectory()?n.push(a):e.push(a)}}return e}(a).map(t=>({action:o.CREATE,path:t})):" A "===n||"?? "===n?[{action:o.CREATE,path:a}]:" M "===n?[{action:o.MODIFY,path:a}]:" D "===n?[{action:o.DELETE,path:a}]:[]})).filter(t=>function(t,{roots:e,names:n}){if(n.has(s.ppath.basename(t)))return!0;do{if(e.has(t))return!0;t=s.ppath.dirname(t)}while("/"!==t);return!1}(t.path,{roots:e,names:n}))},genCommitMessage:async(t,e)=>await f(t,e),async makeCommit(t,e,n){const a=e.map(t=>s.npath.fromPortablePath(t.path));await r.execUtils.execvp("git",["add","-N","--",...a],{cwd:t,strict:!0}),await r.execUtils.execvp("git",["commit","-m",n+"\n\nCommit generated via `yarn stage`\n","--",...a],{cwd:t,strict:!0})},async makeReset(t,e){const n=e.map(t=>s.npath.fromPortablePath(t.path));await r.execUtils.execvp("git",["reset","HEAD","--",...n],{cwd:t,strict:!0})}},{findRoot:async t=>await l(t,{marker:(0,s.toFilename)(".hg")}),filterChanges:async(t,e,n)=>[],genCommitMessage:async(t,e)=>"",async makeCommit(t,e,n){},async makeReset(t,e){},async makeUpdate(t,e){}}];class m extends i.BaseCommand{constructor(){super(...arguments),this.commit=!1,this.reset=!1,this.update=!1,this.dryRun=!1}async execute(){const t=await r.Configuration.find(this.context.cwd,this.context.plugins),{project:e}=await r.Project.find(t,this.context.cwd),{driver:n,root:a}=await async function(t){let e=null,n=null;for(const a of h)if(null!==(n=await a.findRoot(t))){e=a;break}if(null===e||null===n)throw new c.UsageError("No stage driver has been found for your current project");return{driver:e,root:n}}(e.cwd),o=[t.get("bstatePath"),t.get("cacheFolder"),t.get("globalFolder"),t.get("virtualFolder"),t.get("yarnPath")];await t.triggerHook(t=>t.populateYarnPaths,e,t=>{o.push(t)});const i=new Set;for(const t of o)for(const e of g(a,t))i.add(e);const l=new Set([t.get("rcFilename"),t.get("lockfileFilename"),"package.json"]),p=await n.filterChanges(a,i,l),u=await n.genCommitMessage(a,p);if(this.dryRun)if(this.commit)this.context.stdout.write(u+"\n");else for(const t of p)this.context.stdout.write(s.npath.fromPortablePath(t.path)+"\n");else 0===p.length?this.context.stdout.write("No changes found!"):this.commit?await n.makeCommit(a,p,u):this.reset&&await n.makeReset(a,p)}}function g(t,e){const n=[];if(null===e)return n;for(;;){let a;(e===t||e.startsWith(t+"/"))&&n.push(e);try{a=s.xfs.statSync(e)}catch(t){break}if(!a.isSymbolicLink())break;e=s.ppath.resolve(s.ppath.dirname(e),s.xfs.readlinkSync(e))}return n}m.usage=c.Command.Usage({description:"add all yarn files to your vcs",details:"\n      This command will add to your staging area the files belonging to Yarn (typically any modified `package.json` and `.yarnrc.yml` files, but also linker-generated files, cache data, etc). It will take your ignore list into account, so the cache files won't be added if the cache is ignored in a `.gitignore` file (assuming you use Git).\n\n      Running `--reset` will instead remove them from the staging area (the changes will still be there, but won't be committed until you stage them back).\n\n      Since the staging area is a non-existent concept in Mercurial, Yarn will always create a new commit when running this command on Mercurial repositories. You can get this behavior when using Git by using the `--commit` flag which will directly create a commit.\n    ",examples:[["Adds all modified project files to the staging area","yarn stage"],["Creates a new commit containing all modified project files","yarn stage --commit"]]}),a([c.Command.Boolean("-c,--commit")],m.prototype,"commit",void 0),a([c.Command.Boolean("-r,--reset")],m.prototype,"reset",void 0),a([c.Command.Boolean("-u,--update")],m.prototype,"update",void 0),a([c.Command.Boolean("-n,--dry-run")],m.prototype,"dryRun",void 0),a([c.Command.Path("stage")],m.prototype,"execute",null);const w={commands:[m]}},594:t=>{t.exports=require("@yarnpkg/cli")},966:t=>{t.exports=require("@yarnpkg/core")},688:t=>{t.exports=require("@yarnpkg/fslib")},42:t=>{t.exports=require("clipanion")}},e={};function n(a){if(e[a])return e[a].exports;var o=e[a]={exports:{}};return t[a](o,o.exports,n),o.exports}return n.d=(t,e)=>{for(var a in e)n.o(e,a)&&!n.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n(454)})();
return plugin;
}
};