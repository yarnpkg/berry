import {WorkspaceRequiredError}                                                                                         from '@berry/cli';
import {CommandContext, Configuration, MessageName, Project, StreamReport, Workspace, execUtils, structUtils, Manifest} from '@berry/core';
import {Filename, PortablePath, fromPortablePath, ppath, toPortablePath, xfs}                                           from '@berry/fslib';
import {Command, UsageError}                                                                                            from 'clipanion';

// eslint-disable-next-line arca/no-default-export
export default class VersionApplyCommand extends Command<CommandContext> {
  static usage = Command.Usage({
    category: `Release-related commands`,
    description: `check that all the relevant packages have been bumped`,
    details: `
      **Warning:** This command currently requires Git.

      This command will check that all the packages covered by the files listed in argument have been properly bumped or declined to bump.

      In the case of a bump, the check will also cover transitive packages - meaning that should \`Foo\` be bumped, a package \`Bar\` depending on \`Foo\` will require a decision as to whether \`Bar\` will need to be bumped. This check doesn't cross packages that have declined to bump.

      In case no arguments are passed to the function, the list of modified files will be generated by comparing the HEAD against \`master\`.
    `,
    examples: [[
      `Check whether the modified packages need a bump`,
      `yarn version check`,
    ]],
  });

  @Command.Path(`version`, `check`)
  async execute() {
    const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
    const {project, workspace} = await Project.find(configuration, this.context.cwd);

    if (!workspace)
      throw new WorkspaceRequiredError(this.context.cwd);

    const base = `master`;

    const report = await StreamReport.start({
      configuration,
      stdout: this.context.stdout,
    }, async report => {
      const files = await fetchChangedFiles(this.context.cwd, {base});
      const workspaces = new Set(files.map(file => project.getWorkspaceByFilePath(file)));

      const releases = new Set();
      let hasDiffErrors = false;
      let hasDepsErrors = false;

      if (files.length > 0) {
        report.reportInfo(MessageName.UNNAMED, `The following files have changed compared to ${base}:`)
        for (const file of files) {
          report.reportInfo(null, file);
        }
      }

      // First we check which workspaces have received modifications but no release strategies
      for (const workspace of workspaces) {
        const currentNonce = getNonce(workspace.manifest);
        const previousNonce = await fetchPreviousNonce(workspace, {base});

        if (currentNonce === previousNonce) {
          if (!hasDiffErrors && files.length > 0)
            report.reportSeparator();

          report.reportError(MessageName.UNNAMED, `${structUtils.prettyLocator(configuration, workspace.anchoredLocator)} has been modified but doesn't have a bump strategy attached`);
          hasDiffErrors = true;
        } else if (willBeReleased(workspace.manifest)) {
          releases.add(workspace.anchoredLocator.locatorHash);
        }
      }

      // Then we check which workspaces depend on packages that will be released again but have no release strategies themselves
      for (const workspace of project.workspaces) {
        if (willBeReleased(workspace.manifest))
          continue;
        if (workspace.manifest.private)
          continue;

        for (const descriptor of workspace.dependencies.values()) {
          const resolution = project.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`)
            throw new Error(`Assertion failed: The resolution should have been registered`);

          const pkg = project.storedPackages.get(resolution);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: The package should have been registered`);

          if (releases.has(resolution)) {
            if (!hasDepsErrors && (files.length > 0 || hasDiffErrors))
              report.reportSeparator();

            report.reportError(MessageName.UNNAMED, `${structUtils.prettyLocator(configuration, workspace.anchoredLocator)} doesn't have a bump strategy attached, but depends on ${structUtils.prettyLocator(configuration, pkg)} which will be re-released.`);
            hasDepsErrors = true;
          }
        }
      }

      if (hasDiffErrors || hasDepsErrors) {
        report.reportSeparator();

        report.reportInfo(MessageName.UNNAMED, `This command detected that at least some workspaces have received modifications but no explicit instructions as to how they had to be released (if needed).`);
        report.reportInfo(MessageName.UNNAMED, `To correct these errors, run \`yarn version ... --deferred\` in each of them with the adequate bump strategies, then run \`yarn version check\` again.`);
      }
    });

    return report.exitCode();
  }
}

async function fetchRoot(initialCwd: PortablePath) {
  // Note: We can't just use `git rev-parse --show-toplevel`, because on Windows
  // it may return long paths even when the cwd uses short paths, and we have no
  // way to detect it from Node (not even realpath).

  let match: PortablePath | null = null;

  let cwd: PortablePath;
  let nextCwd = initialCwd;
  do {
    cwd = nextCwd;
    if (await xfs.existsPromise(ppath.join(cwd, `.git` as Filename)))
      match = cwd;
    nextCwd = ppath.dirname(cwd);
  } while (match === null && nextCwd !== cwd);

  if (match === null)
    throw new UsageError(`This command can only be run from within a Git repository`);

  return match;
}

async function fetchChangedFiles(cwd: PortablePath, {base}: {base: string}) {
  const root = await fetchRoot(cwd);

  const {stdout: diffStdout} = await execUtils.execvp(`git`, [`diff`, `--name-only`, base], {cwd, strict: true});
  const files = diffStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => ppath.resolve(root, toPortablePath(file)));

  const {stdout: untrackedStdout} = await execUtils.execvp(`git`, [`ls-files`, `--others`, `--exclude-standard`], {cwd, strict: true});
  const moreFiles = untrackedStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => ppath.resolve(root, toPortablePath(file)));

  return [...files, ...moreFiles];
}

async function fetchPreviousNonce(workspace: Workspace, {base}: {base: string}) {
  const {code, stdout} = await execUtils.execvp(`git`, [`show`, `${base}:${fromPortablePath(ppath.join(workspace.cwd, `package.json` as Filename))}`], {cwd: workspace.cwd});

  if (code === 0) {
    return getNonce(Manifest.fromText(stdout));
  } else {
    return null;
  }
}

function getNonce(manifest: Manifest) {
  if (manifest.raw.nextVersion && (typeof manifest.raw.nextVersion.nonce === `string` || typeof manifest.raw.nextVersion.nonce === `number`)) {
    return String(manifest.raw.nextVersion.nonce);
  } else {
    return null;
  }
}

function willBeReleased(manifest: Manifest) {
  if (manifest.raw.nextVersion && typeof manifest.raw.nextVersion.semver === `string` && manifest.raw.nextVersion !== manifest.raw.version) {
    return true;
  } else {
    return false;
  }
}
