import {WorkspaceRequiredError}                                                                                         from '@yarnpkg/cli';
import {CommandContext, Configuration, MessageName, Project, StreamReport, Workspace, execUtils, structUtils, Manifest} from '@yarnpkg/core';
import {Filename, PortablePath, fromPortablePath, ppath, toPortablePath, xfs}                                           from '@yarnpkg/fslib';
import {Command, UsageError}                                                                                            from 'clipanion';

// eslint-disable-next-line arca/no-default-export
export default class VersionApplyCommand extends Command<CommandContext> {
  static usage = Command.Usage({
    category: `Release-related commands`,
    description: `check that all the relevant packages have been bumped`,
    details: `
      **Warning:** This command currently requires Git.

      This command will check that all the packages covered by the files listed in argument have been properly bumped or declined to bump.

      In the case of a bump, the check will also cover transitive packages - meaning that should \`Foo\` be bumped, a package \`Bar\` depending on \`Foo\` will require a decision as to whether \`Bar\` will need to be bumped. This check doesn't cross packages that have declined to bump.

      In case no arguments are passed to the function, the list of modified files will be generated by comparing the HEAD against \`master\`.
    `,
    examples: [[
      `Check whether the modified packages need a bump`,
      `yarn version check`,
    ]],
  });

  @Command.Path(`version`, `check`)
  async execute() {
    const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
    const {project, workspace} = await Project.find(configuration, this.context.cwd);

    if (!workspace)
      throw new WorkspaceRequiredError(this.context.cwd);

    const report = await StreamReport.start({
      configuration,
      stdout: this.context.stdout,
    }, async report => {
      const root = await fetchRoot(this.context.cwd);
      const base = await fetchBase(root);

      const files = await fetchChangedFiles(root, {base: base.hash});
      const workspaces = new Set(files.map(file => project.getWorkspaceByFilePath(file)));

      const releases = new Set();
      let hasDiffErrors = false;
      let hasDepsErrors = false;

      report.reportInfo(MessageName.UNNAMED, `Your PR was started right after ${configuration.format(base.hash.slice(0, 7), `yellow`)} ${configuration.format(base.message, `magenta`)}`);

      if (files.length > 0) {
        report.reportInfo(MessageName.UNNAMED, `you have changed the following files since then:`)
        for (const file of files) {
          report.reportInfo(null, file);
        }
      }

      // First we check which workspaces have received modifications but no release strategies
      for (const workspace of workspaces) {
        // Let's assume that packages without versions don't need to see their version increased
        if (workspace.manifest.version === null)
          continue;

        const currentNonce = getNonce(workspace.manifest);
        const previousNonce = await fetchPreviousNonce(workspace, {root, base: base.hash});

        // If the nonce is the same, it means that the user didn't run one of the `yarn version <>` variants since they started working on this diff
        if (currentNonce === previousNonce) {
          if (!hasDiffErrors && files.length > 0)
            report.reportSeparator();

          report.reportError(MessageName.UNNAMED, `${structUtils.prettyLocator(configuration, workspace.anchoredLocator)} has been modified but doesn't have a bump strategy attached`);
          hasDiffErrors = true;
        } else {
          // If it changed and a bump is planned, we mark it so that we can check that its dependents also chose whether they want to be bumped or not
          if (willBeReleased(workspace.manifest)) {
            releases.add(workspace.anchoredLocator.locatorHash);
          }
        }
      }

      // Then we check which workspaces depend on packages that will be released again but have no release strategies themselves
      for (const workspace of project.workspaces) {
        // We don't need to check whether the dependencies of packages that will be bumped because of this PR changed
        if (releases.has(workspace.anchoredLocator.locatorHash))
          continue;
        // We also don't need to check whether the dependencies of private packages changed, as they are supposed to only make sense within the context of the monorepo
        if (workspace.manifest.private)
          continue;
        // Let's assume that packages without versions don't need to see their version increased
        if (workspace.manifest.version === null)
          continue;

        for (const descriptor of workspace.dependencies.values()) {
          const resolution = project.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`)
            throw new Error(`Assertion failed: The resolution should have been registered`);

          const pkg = project.storedPackages.get(resolution);
          if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: The package should have been registered`);

          // We only care about workspaces, and we only care about workspaces that will be bumped
          if (!releases.has(resolution))
            continue;

          // Quick note: we don't want to check whether the workspace pointer
          // by `resolution` is private, because while it doesn't makes sense
          // to bump a private package because its dependencies changed, the
          // opposite isn't true: a (public) package might need to be bumped
          // because one of its dev dependencies is a (private) package whose
          // behavior sensibly changed.

          if (!hasDepsErrors && (files.length > 0 || hasDiffErrors))
            report.reportSeparator();

          report.reportError(MessageName.UNNAMED, `${structUtils.prettyLocator(configuration, workspace.anchoredLocator)} doesn't have a bump strategy attached, but depends on ${structUtils.prettyLocator(configuration, pkg)} which will be re-released.`);
          hasDepsErrors = true;
        }
      }

      if (hasDiffErrors || hasDepsErrors) {
        report.reportSeparator();

        report.reportInfo(MessageName.UNNAMED, `This command detected that at least some workspaces have received modifications but no explicit instructions as to how they had to be released (if needed).`);
        report.reportInfo(MessageName.UNNAMED, `To correct these errors, run \`yarn version ... --deferred\` in each of them with the adequate bump strategies, then run \`yarn version check\` again.`);
      }
    });

    return report.exitCode();
  }
}

async function fetchBase(root: PortablePath) {
  const candidateBases = [`master`, `origin/master`, `upstream/master`];
  const ancestorBases = [];

  for (const candidate of candidateBases) {
    const {code} = await execUtils.execvp(`git`, [`merge-base`, candidate, `HEAD`], {cwd: root});
    if (code === 0) {
      ancestorBases.push(candidate);
    }
  }

  if (ancestorBases.length === 0)
    throw new UsageError(`No ancestor could be found between any of HEAD and ${candidateBases.join(`, `)}`);

  const {stdout: mergeBaseStdout} = await execUtils.execvp(`git`, [`merge-base`, `HEAD`, ...ancestorBases], {cwd: root, strict: true});
  const hash = mergeBaseStdout.trim();

  const {stdout: showStdout} = await execUtils.execvp(`git`, [`show`, `--quiet`, `--pretty=format:%s`, hash], {cwd: root, strict: true});
  const message = showStdout.trim();

  return {hash, message};
}

async function fetchRoot(initialCwd: PortablePath) {
  // Note: We can't just use `git rev-parse --show-toplevel`, because on Windows
  // it may return long paths even when the cwd uses short paths, and we have no
  // way to detect it from Node (not even realpath).

  let match: PortablePath | null = null;

  let cwd: PortablePath;
  let nextCwd = initialCwd;
  do {
    cwd = nextCwd;
    if (await xfs.existsPromise(ppath.join(cwd, `.git` as Filename)))
      match = cwd;
    nextCwd = ppath.dirname(cwd);
  } while (match === null && nextCwd !== cwd);

  if (match === null)
    throw new UsageError(`This command can only be run from within a Git repository`);

  return match;
}

async function fetchChangedFiles(root: PortablePath, {base}: {base: string}) {
  const {stdout: diffStdout} = await execUtils.execvp(`git`, [`diff`, `--name-only`, base], {cwd: root, strict: true});
  const files = diffStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => ppath.resolve(root, toPortablePath(file)));

  const {stdout: untrackedStdout} = await execUtils.execvp(`git`, [`ls-files`, `--others`, `--exclude-standard`], {cwd: root, strict: true});
  const moreFiles = untrackedStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => ppath.resolve(root, toPortablePath(file)));

  return [...files, ...moreFiles];
}

async function fetchPreviousNonce(workspace: Workspace, {root, base}: {root: PortablePath, base: string}) {
  const {code, stdout} = await execUtils.execvp(`git`, [`show`, `${base}:${fromPortablePath(ppath.relative(root, ppath.join(workspace.cwd, `package.json` as Filename)))}`], {cwd: workspace.cwd});

  if (code === 0) {
    return getNonce(Manifest.fromText(stdout));
  } else {
    return null;
  }
}

function getNonce(manifest: Manifest) {
  if (manifest.raw.nextVersion && (typeof manifest.raw.nextVersion.nonce === `string` || typeof manifest.raw.nextVersion.nonce === `number`)) {
    return String(manifest.raw.nextVersion.nonce);
  } else {
    return null;
  }
}

function willBeReleased(manifest: Manifest) {
  if (manifest.raw.nextVersion && typeof manifest.raw.nextVersion.semver === `string` && manifest.raw.nextVersion !== manifest.raw.version) {
    return true;
  } else {
    return false;
  }
}
