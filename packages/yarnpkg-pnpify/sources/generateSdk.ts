import {Report, MessageName, miscUtils, Configuration, FormatType} from '@yarnpkg/core';
import {Filename, PortablePath, npath, ppath, xfs}                 from '@yarnpkg/fslib';
import {parseSyml, stringifySyml}                                  from '@yarnpkg/parsers';
import {PnpApi}                                                    from '@yarnpkg/pnp';
import chalk                                                       from 'chalk';
import {UsageError}                                                from 'clipanion';
import {startCase, capitalize}                                     from 'lodash';

import {dynamicRequire}                                            from './dynamicRequire';

import {BASE_SDKS}                                                 from './sdks/base';
import {VSCODE_SDKS}                                               from './sdks/vscode';

export const PNPIFY_FOLDER = `.yarn/pnpify` as PortablePath;

export const EDITORS_FILE = `editors.yml` as Filename;

export const SUPPORTED_EDITORS = new Map([
  [`vscode`, VSCODE_SDKS],
] as const);

export const getDisplayName = (name: string) =>
  startCase(name).split(` `).map(word => capitalize(word)).join(` `);

export const validateEditors = (editors: Set<string>) => {
  const unsupportedEditors: Array<string> = [];

  for (const editor of editors) {
    if (!SUPPORTED_EDITORS.has(editor as SupportedEditor)) {
      unsupportedEditors.push(editor);
    }
  }

  if (unsupportedEditors.length > 0) {
    throw new UsageError(`No supported editors with the following names could be found: ${unsupportedEditors.join(`, `)}`);
  }
};

export type MapKey<S> = S extends Map<infer K, infer V> ? K : never;

export type SupportedEditor = MapKey<typeof SUPPORTED_EDITORS>;

export class EditorsFile {
  public editors: Set<SupportedEditor> = new Set();

  public raw: {[key: string]: any} = {};

  async loadFile(path: PortablePath) {
    const content = await xfs.readFilePromise(path, `utf8`);

    let data;
    try {
      data = parseSyml(content || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${path})`;
      throw error;
    }

    this.load(data);
  }

  load(data: any) {
    if (typeof data !== `object` || data === null)
      throw new Error(`Utterly invalid editors file data (${data})`);

    this.raw = data;

    if (Array.isArray(data.editors)) {
      this.editors = new Set(data.editors);
      validateEditors(this.editors);
    }
  }

  exportTo(data: {[key: string]: any}) {
    if (this.editors.size > 0)
      data.editors = [...this.editors];

    return data;
  }

  async persist(dir: PortablePath) {
    const data = {};
    this.exportTo(data);

    const path = ppath.join(dir, EDITORS_FILE);
    let content = `# This file is automatically generated by PnPify.\n# Manual changes will be lost!\n\n`;
    content += stringifySyml(data);

    await xfs.mkdirpPromise(ppath.dirname(path));
    await xfs.changeFilePromise(path, content, {
      automaticNewlines: true,
    });
  }
}

type TemplateOptions = {
  setupEnv?: boolean,
  usePnpify?: boolean,
  wrapModule?: string,
};

const TEMPLATE = (relPnpApiPath: PortablePath, module: string, {setupEnv = false, usePnpify = false, wrapModule}: TemplateOptions) => [
  `#!/usr/bin/env node\n`,
  `\n`,
  `const {existsSync} = require(\`fs\`);\n`,
  `const {createRequire, createRequireFromPath} = require(\`module\`);\n`,
  `const {resolve} = require(\`path\`);\n`,
  `\n`,
  `const relPnpApiPath = ${JSON.stringify(npath.fromPortablePath(relPnpApiPath))};\n`,
  `\n`,
  `const absPnpApiPath = resolve(__dirname, relPnpApiPath);\n`,
  `const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);\n`,
  `\n`,
  ...(wrapModule ? [
    `const moduleWrapper = ${wrapModule.trim().replace(/^ {4}/gm, ``)}\n`,
    `\n`,
  ] : []),
  `if (existsSync(absPnpApiPath)) {\n`,
  `  if (!process.versions.pnp) {\n`,
  `    // Setup the environment to be able to require ${module}\n`,
  `    require(absPnpApiPath).setup();\n`,
  `  }\n`,
  ...(setupEnv ? [
    `\n`,
    `  if (typeof global[\`__yarnpkg_sdk_has_setup_env__\`] === \`undefined\`) {\n`,
    `    Object.defineProperty(global, \`__yarnpkg_sdk_has_setup_env__\`, {configurable: true, value: true});\n`,
    `\n`,
    `    process.env.NODE_OPTIONS = process.env.NODE_OPTIONS || \`\`;\n`,
    `    process.env.NODE_OPTIONS += \` -r \${absPnpApiPath}\`;\n`,
    `  }\n`,
  ] : []),
  ...(usePnpify ? [
    `\n`,
    `  if (typeof global[\`__yarnpkg_sdk_is_using_pnpify__\`] === \`undefined\`) {\n`,
    `    Object.defineProperty(global, \`__yarnpkg_sdk_is_using_pnpify__\`, {configurable: true, value: true});\n`,
    `\n`,
    `    process.env.NODE_OPTIONS += \` -r \${pnpifyResolution}\`;\n`,
    `\n`,
    `    // Apply PnPify to the current process\n`,
    `    absRequire(\`@yarnpkg/pnpify\`).patchFs();\n`,
    `  }\n`,
  ] : []),
  `}\n`,
  `\n`,
  `// Defer to the real ${module} your application uses\n`,
  wrapModule ? `module.exports = moduleWrapper(absRequire(\`${module}\`));\n` : `module.exports = absRequire(\`${module}\`);\n`,
].join(``);

export type GenerateBaseWrapper = (pnpApi: PnpApi, target: PortablePath) => Promise<Wrapper>;

export type GenerateEditorWrapper = (pnpApi: PnpApi, target: PortablePath, wrapper: Wrapper) => Promise<void>;

export type SupportedSdk =
 | 'eslint'
 | 'prettier'
 | 'typescript-language-server'
 | 'typescript'
 | 'stylelint';

export type BaseSdks = Array<[SupportedSdk, GenerateBaseWrapper]>;

export type EditorSdks = Array<[SupportedSdk, GenerateEditorWrapper | null]>;

export class Wrapper {
  private name: PortablePath;

  private pnpApi: PnpApi;
  private target: PortablePath;

  private paths: Map<PortablePath, PortablePath> = new Map();

  constructor(name: PortablePath, {pnpApi, target}: {pnpApi: PnpApi, target: PortablePath}) {
    this.name = name;

    this.pnpApi = pnpApi;
    this.target = target;
  }

  async writeManifest() {
    const absWrapperPath = ppath.join(this.target, this.name, `package.json` as Filename);

    const topLevelInformation = this.pnpApi.getPackageInformation(this.pnpApi.topLevel)!;
    const dependencyReference = topLevelInformation.packageDependencies.get(this.name)!;

    const pkgInformation = this.pnpApi.getPackageInformation(this.pnpApi.getLocator(this.name, dependencyReference));
    if (pkgInformation === null)
      throw new Error(`Assertion failed: Package ${this.name} isn't a dependency of the top-level`);

    const manifest = dynamicRequire(npath.join(pkgInformation.packageLocation, `package.json`));

    await xfs.mkdirpPromise(ppath.dirname(absWrapperPath));
    await xfs.writeFilePromise(absWrapperPath, JSON.stringify({
      name: this.name,
      version: `${manifest.version}-pnpify`,
      main: manifest.main,
      type: `commonjs`,
    }, null, 2));
  }

  async writeBinary(relPackagePath: PortablePath, options: TemplateOptions = {}) {
    const absPackagePath = await this.writeFile(relPackagePath, options);

    await xfs.chmodPromise(absPackagePath, 0o755);
  }

  async writeFile(relPackagePath: PortablePath, options: TemplateOptions = {}) {
    const topLevelInformation = this.pnpApi.getPackageInformation(this.pnpApi.topLevel)!;
    const projectRoot = npath.toPortablePath(topLevelInformation.packageLocation);

    const absWrapperPath = ppath.join(this.target, this.name, relPackagePath);
    const relProjectPath = ppath.relative(projectRoot, absWrapperPath);

    const absPnpApiPath = npath.toPortablePath(this.pnpApi.resolveRequest(`pnpapi`, null)!);
    const relPnpApiPath = ppath.relative(ppath.dirname(absWrapperPath), absPnpApiPath);

    await xfs.mkdirpPromise(ppath.dirname(absWrapperPath));
    await xfs.writeFilePromise(absWrapperPath, TEMPLATE(relPnpApiPath, ppath.join(this.name, relPackagePath), options));

    this.paths.set(relPackagePath, relProjectPath);

    return absWrapperPath;
  }

  getProjectPathTo(relPackagePath: PortablePath) {
    const relProjectPath = this.paths.get(relPackagePath);

    if (typeof relProjectPath === `undefined`)
      throw new Error(`Assertion failed: Expected path to have been registered`);

    return relProjectPath;
  }
}

export const generateSdk = async (pnpApi: PnpApi, requestedEditors: Set<SupportedEditor>, {report, onlyBase, configuration}: {report: Report, onlyBase: boolean, configuration: Configuration}): Promise<void> => {
  validateEditors(requestedEditors);

  const topLevelInformation = pnpApi.getPackageInformation(pnpApi.topLevel)!;
  const projectRoot = npath.toPortablePath(topLevelInformation.packageLocation);

  const targetFolder = ppath.join(projectRoot, PNPIFY_FOLDER);
  const editorsFilePath = ppath.join(targetFolder, EDITORS_FILE);

  const hasEditorsFile = xfs.existsSync(editorsFilePath);

  const editorsFile = new EditorsFile();
  if (hasEditorsFile)
    await editorsFile.loadFile(editorsFilePath);
  const preexistingEditors = editorsFile.editors;

  const allEditors = new Set([
    ...requestedEditors,
    ...preexistingEditors,
  ]);

  if (allEditors.size === 0 && !hasEditorsFile && !onlyBase)
    throw new UsageError(`No editors have been provided as arguments and no existing editors could be found inside the ${configuration.format(EDITORS_FILE, FormatType.PATH)} file. Make sure to use \`yarn pnpify --sdk <editors>\`, or run \`yarn pnpify --sdk base\` if you prefer to manage your own settings.`);

  // TODO: remove in next major
  const OLD_PNPIFY_FOLDER = `.vscode/pnpify` as PortablePath;
  const oldTargetFolder = ppath.join(projectRoot, OLD_PNPIFY_FOLDER);
  if (xfs.existsSync(oldTargetFolder)) {
    report.reportWarning(MessageName.UNNAMED, `Cleaning up the existing SDK files in the old ${configuration.format(OLD_PNPIFY_FOLDER, FormatType.PATH)} folder. You might need to manually update existing references outside the ${configuration.format(`.vscode`, FormatType.PATH)} folder (e.g. .gitignore)...`);
    await xfs.removePromise(oldTargetFolder);
  }

  if (xfs.existsSync(targetFolder)) {
    report.reportInfo(null, `Cleaning up the existing SDK files...`);
    await xfs.removePromise(targetFolder);
  }

  editorsFile.editors = allEditors;
  await editorsFile.persist(targetFolder);

  report.reportInfo(null, `Installing fresh SDKs for ${configuration.format(projectRoot, FormatType.PATH)}:`);
  report.reportSeparator();

  report.reportInfo(null, `Installing the base SDKs inside ${configuration.format(targetFolder, FormatType.PATH)}...`);
  report.reportSeparator();

  if (allEditors.size > 0) {
    report.reportInfo(null, `Editors:`);
    for (const editor of requestedEditors)
      report.reportInfo(MessageName.UNNAMED, `${chalk.green(`✓`)} ${getDisplayName(editor)} (new ✨)`);
    for (const editor of preexistingEditors)
      if (!requestedEditors.has(editor))
        report.reportInfo(MessageName.UNNAMED, `${chalk.green(`✓`)} ${getDisplayName(editor)} (updated 🔼)`);
    report.reportSeparator();
  }

  const editorSdks = miscUtils.mapAndFilter(SUPPORTED_EDITORS, ([editor, sdk]) => {
    if (!allEditors.has(editor))
      return miscUtils.mapAndFilter.skip;

    return sdk;
  });

  report.reportInfo(null, `Dependencies:`);

  let skippedSome = false;

  for (const [pkgName, generateBaseWrapper] of BASE_SDKS) {
    const displayName = getDisplayName(pkgName);

    if (topLevelInformation.packageDependencies.has(pkgName)) {
      report.reportInfo(MessageName.UNNAMED, `${chalk.green(`✓`)} ${displayName}`);
      const wrapper = await generateBaseWrapper(pnpApi, targetFolder);

      for (const sdks of editorSdks) {
        const editorSdk = sdks.find(sdk => sdk[0] === pkgName);

        if (!editorSdk)
          continue;

        const [, generateEditorWrapper] = editorSdk;

        if (!generateEditorWrapper)
          continue;

        await generateEditorWrapper(pnpApi, targetFolder, wrapper);
      }
    } else {
      report.reportInfo(null, `${chalk.yellow(`•`)} ${displayName} (dependency not found; skipped)`);
      skippedSome = true;
    }
  }

  if (skippedSome) {
    report.reportSeparator();
    report.reportInfo(null, `Note that, in order to be detected, those packages have to be listed as top-level dependencies (listing them into each individual workspace won't be enough).`);
  }
};
