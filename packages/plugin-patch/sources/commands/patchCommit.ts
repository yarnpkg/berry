import {BaseCommand, WorkspaceRequiredError}       from '@yarnpkg/cli';
import {Configuration, Project, structUtils}       from '@yarnpkg/core';
import {npath, xfs, ppath, PortablePath, Filename} from '@yarnpkg/fslib';
import {Command, Option, Usage, UsageError}        from 'clipanion';

import * as patchUtils                             from '../patchUtils';

// eslint-disable-next-line arca/no-default-export
export default class PatchCommitCommand extends BaseCommand {
  static paths = [
    [`patch-commit`],
  ];

  static usage: Usage = Command.Usage({
    description: `generate a patch out of a directory`,
    details: `
      By default, this will print a patchfile on stdout based on the diff between the folder passed in and the original version of the package. Such file is suitable for consumption with the \`patch:\` protocol.

      With the \`-s,--save\` option set, the patchfile won't be printed on stdout anymore and will instead be stored within a local file (by default kept within \`.yarn/patches\`, but configurable via the \`patchFolder\` setting). A \`resolutions\` entry will also be added to your top-level manifest, referencing the patched package via the \`patch:\` protocol.

      Note that only folders generated by \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `,
  });

  save = Option.Boolean(`-s,--save`, false, {
    description: `Add the patch to your resolution entries`,
  });

  patchFolder = Option.String();

  async execute() {
    const configuration = await Configuration.find(this.context.cwd, this.context.plugins);
    const {project, workspace} = await Project.find(configuration, this.context.cwd);

    if (!workspace)
      throw new WorkspaceRequiredError(project.cwd, this.context.cwd);

    await project.restoreInstallState();

    const folderPath = ppath.resolve(this.context.cwd, npath.toPortablePath(this.patchFolder));
    const sourcePath = ppath.join(folderPath, `../source` as PortablePath);
    const metaPath = ppath.join(folderPath, `../.yarn-patch.json` as PortablePath);

    if (!xfs.existsSync(sourcePath))
      throw new UsageError(`The argument folder didn't get created by 'yarn patch'`);

    const diff = await patchUtils.diffFolders(sourcePath, folderPath);

    const meta = await xfs.readJsonPromise(metaPath);
    const locator = structUtils.parseLocator(meta.locator, true);

    if (!project.storedPackages.has(locator.locatorHash))
      throw new UsageError(`No package found in the project for the given locator`);

    if (!this.save) {
      this.context.stdout.write(diff);
      return;
    }

    const patchFolder = configuration.get(`patchFolder`);
    const patchPath = ppath.join(patchFolder, `${structUtils.slugifyLocator(locator)}.patch` as Filename);

    await xfs.mkdirPromise(patchFolder, {recursive: true});
    await xfs.writeFilePromise(patchPath, diff);

    const relPath = ppath.relative(project.cwd, patchPath);

    project.topLevelWorkspace.manifest.resolutions.push({
      pattern: {descriptor: {fullName: structUtils.stringifyIdent(locator), description: meta.version}},
      reference: `patch:${structUtils.stringifyLocator(locator)}#${relPath}`,
    });

    await project.persist();
  }
}
