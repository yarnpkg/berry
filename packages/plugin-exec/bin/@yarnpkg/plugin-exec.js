/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-exec",
factory: function (require) {
var plugin=(()=>{var V=Object.create,d=Object.defineProperty,_=Object.defineProperties,G=Object.getOwnPropertyDescriptor,z=Object.getOwnPropertyDescriptors,J=Object.getOwnPropertyNames,j=Object.getOwnPropertySymbols,Y=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable;var U=(r,e,t)=>e in r?d(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,u=(r,e)=>{for(var t in e||(e={}))S.call(e,t)&&U(r,t,e[t]);if(j)for(var t of j(e))B.call(e,t)&&U(r,t,e[t]);return r},T=(r,e)=>_(r,z(e)),K=r=>d(r,"__esModule",{value:!0});var C=(r,e)=>{for(var t in e)d(r,t,{get:e[t],enumerable:!0})},Q=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of J(e))!S.call(r,a)&&a!=="default"&&d(r,a,{get:()=>e[a],enumerable:!(t=G(e,a))||t.enumerable});return r},h=r=>Q(K(d(r!=null?V(Y(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var Z={};C(Z,{default:()=>te,execUtils:()=>y});var l=h(require("@yarnpkg/core")),O=h(require("@yarnpkg/core")),n=h(require("@yarnpkg/fslib"));var p="exec:";var y={};C(y,{loadGeneratorFile:()=>P,makeLocator:()=>x,makeSpec:()=>A,parseSpec:()=>v});var f=h(require("@yarnpkg/core")),c=h(require("@yarnpkg/fslib"));function v(r){let{params:e,selector:t}=f.structUtils.parseRange(r),a=c.npath.toPortablePath(t);return{parentLocator:e&&typeof e.locator=="string"?f.structUtils.parseLocator(e.locator):null,path:a}}function A({parentLocator:r,path:e,generatorHash:t,protocol:a}){let o=r!==null?{locator:f.structUtils.stringifyLocator(r)}:{},i=typeof t!="undefined"?{hash:t}:{};return f.structUtils.makeRange({protocol:a,source:e,selector:e,params:u(u({},i),o)})}function x(r,{parentLocator:e,path:t,generatorHash:a,protocol:o}){return f.structUtils.makeLocator(r,A({parentLocator:e,path:t,generatorHash:a,protocol:o}))}async function P(r,e,t){let{parentLocator:a,path:o}=f.structUtils.parseFileStyleRange(r,{protocol:e}),i=c.ppath.isAbsolute(o)?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.PortablePath.dot,localPath:c.PortablePath.root}:await t.fetcher.fetch(a,t),s=i.localPath?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.ppath.relative(c.PortablePath.root,i.localPath)}:i;i!==s&&i.releaseFs&&i.releaseFs();let g=s.packageFs,b=c.ppath.join(s.prefixPath,o);return await g.readFilePromise(b,"utf8")}var L=class{supports(e,t){return!!e.reference.startsWith(p)}getLocalPath(e,t){let{parentLocator:a,path:o}=l.structUtils.parseFileStyleRange(e.reference,{protocol:p});if(n.ppath.isAbsolute(o))return o;let i=t.fetcher.getLocalPath(a,t);return i===null?null:n.ppath.resolve(i,o)}async fetch(e,t){let a=t.checksums.get(e.locatorHash)||null,[o,i,s]=await t.cache.fetchPackageFromCache(e,a,u({onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e),loader:()=>this.fetchFromDisk(e,t),skipIntegrityCheck:t.skipIntegrityCheck},t.cacheOptions));return{packageFs:o,releaseFs:i,prefixPath:l.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:s}}async fetchFromDisk(e,t){let a=await P(e.reference,p,t);return n.xfs.mktempPromise(async o=>{let i=n.ppath.join(o,"generator.js");return await n.xfs.writeFilePromise(i,a),n.xfs.mktempPromise(async s=>{if(await this.generatePackage(s,e,i,t),!n.xfs.existsSync(n.ppath.join(s,"build")))throw new Error("The script should have generated a build directory");return await l.tgzUtils.makeArchiveFromDirectory(n.ppath.join(s,"build"),{prefixPath:l.structUtils.getIdentVendorPath(e),compressionLevel:t.project.configuration.get("compressionLevel")})})})}async generatePackage(e,t,a,o){return await n.xfs.mktempPromise(async i=>{let s=await l.scriptUtils.makeScriptEnv({project:o.project,binFolder:i}),g=n.ppath.join(e,"runtime.js");return await n.xfs.mktempPromise(async b=>{let E=n.ppath.join(b,"buildfile.log"),I=null,F=n.xfs.createWriteStream(E),W=F,R=n.ppath.join(e,"generator"),D=n.ppath.join(e,"build");await n.xfs.mkdirPromise(R),await n.xfs.mkdirPromise(D);let $={tempDir:n.npath.fromPortablePath(R),buildDir:n.npath.fromPortablePath(D),locator:l.structUtils.stringifyLocator(t)};await n.xfs.writeFilePromise(g,`
          // Expose 'Module' as a global variable
          Object.defineProperty(global, 'Module', {
            get: () => require('module'),
            configurable: true,
            enumerable: false,
          });

          // Expose non-hidden built-in modules as global variables
          for (const name of Module.builtinModules.filter((name) => name !== 'module' && !name.startsWith('_'))) {
            Object.defineProperty(global, name, {
              get: () => require(name),
              configurable: true,
              enumerable: false,
            });
          }

          // Expose the 'execEnv' global variable
          Object.defineProperty(global, 'execEnv', {
            value: {
              ...${JSON.stringify($)},
            },
            enumerable: true,
          });
        `);let k=s.NODE_OPTIONS||"",q=/\s*--require\s+\S*\.pnp\.c?js\s*/g;k=k.replace(q," ").trim(),s.NODE_OPTIONS=k,F.write(`# This file contains the result of Yarn generating a package (${l.structUtils.stringifyLocator(t)})
`),F.write(`
`);let{code:M}=await l.execUtils.pipevp(process.execPath,["--require",n.npath.fromPortablePath(g),n.npath.fromPortablePath(a),l.structUtils.stringifyIdent(t)],{cwd:e,env:s,stdin:I,stdout:F,stderr:W});if(M!==0)throw n.xfs.detachTemp(b),new Error(`Package generation failed (exit code ${M}, logs can be found here: ${O.formatUtils.pretty(o.project.configuration,E,O.formatUtils.Type.PATH)})`)})})}};var N=h(require("@yarnpkg/core")),H=h(require("@yarnpkg/core")),m=h(require("@yarnpkg/core"));var X=2,w=class{supportsDescriptor(e,t){return!!e.range.startsWith(p)}supportsLocator(e,t){return!!e.reference.startsWith(p)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,a){return m.structUtils.bindDescriptor(e,{locator:m.structUtils.stringifyLocator(t)})}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,a){if(!a.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let{path:o,parentLocator:i}=v(e.range);if(i===null)throw new Error("Assertion failed: The descriptor should have been bound");let s=await P(m.structUtils.makeRange({protocol:p,source:o,selector:o,params:{locator:m.structUtils.stringifyLocator(i)}}),p,a.fetchOptions),g=m.hashUtils.makeHash(`${X}`,s).slice(0,6);return[x(e,{parentLocator:i,path:o,generatorHash:g,protocol:p})]}async getSatisfying(e,t,a){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let a=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),o=await m.miscUtils.releaseAfterUseAsync(async()=>await N.Manifest.find(a.prefixPath,{baseFs:a.packageFs}),a.releaseFs);return T(u({},e),{version:o.version||"0.0.0",languageName:o.languageName||t.project.configuration.get("defaultLanguageName"),linkType:H.LinkType.HARD,conditions:o.getConditions(),dependencies:o.dependencies,peerDependencies:o.peerDependencies,dependenciesMeta:o.dependenciesMeta,peerDependenciesMeta:o.peerDependenciesMeta,bin:o.bin})}};var ee={fetchers:[L],resolvers:[w]},te=ee;return Z;})();
return plugin;
}
};
