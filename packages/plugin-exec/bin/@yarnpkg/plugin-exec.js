module.exports={name:"@yarnpkg/plugin-exec",factory:function(e){return function(e){var t={};function r(a){if(t[a])return t[a].exports;var n=t[a]={i:a,l:!1,exports:{}};return e[a].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,a){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(a,n,function(t){return e[t]}.bind(null,n));return a},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(t,r){t.exports=e("@yarnpkg/fslib")},function(t,r){t.exports=e("@yarnpkg/core")},function(e,t,r){"use strict";r.r(t);var a={};r.r(a),r.d(a,"parseSpec",(function(){return i})),r.d(a,"makeSpec",(function(){return c})),r.d(a,"makeLocator",(function(){return l})),r.d(a,"loadGeneratorFile",(function(){return p}));var n=r(1),o=r(0);const s="exec:";function i(e){const{params:t,selector:r}=n.structUtils.parseRange(e),a=o.npath.toPortablePath(r);return{parentLocator:t&&"string"==typeof t.locator?n.structUtils.parseLocator(t.locator):null,path:a}}function c({parentLocator:e,path:t,generatorHash:r,protocol:a}){const o=null!==e?{locator:n.structUtils.stringifyLocator(e)}:{},s=void 0!==r?{hash:r}:{};return n.structUtils.makeRange({protocol:a,source:t,selector:t,params:{...s,...o}})}function l(e,{parentLocator:t,path:r,generatorHash:a,protocol:o}){return n.structUtils.makeLocator(e,c({parentLocator:t,path:r,generatorHash:a,protocol:o}))}async function p(e,t,r){const{parentLocator:a,path:s}=n.structUtils.parseFileStyleRange(e,{protocol:t}),i=o.ppath.isAbsolute(s)?{packageFs:new o.CwdFS(o.PortablePath.root),prefixPath:o.PortablePath.dot,localPath:o.PortablePath.root}:await r.fetcher.fetch(a,r),c=i.localPath?{packageFs:new o.CwdFS(o.PortablePath.root),prefixPath:o.ppath.relative(o.PortablePath.root,i.localPath)}:i;i!==c&&i.releaseFs&&i.releaseFs();const l=c.packageFs,p=o.ppath.join(c.prefixPath,s);return await l.readFilePromise(p,"utf8")}const u=1;r.d(t,"execUtils",(function(){return a}));const f={fetchers:[class{supports(e,t){return!!e.reference.startsWith(s)}getLocalPath(e,t){const{parentLocator:r,path:a}=n.structUtils.parseFileStyleRange(e.reference,{protocol:s});if(o.ppath.isAbsolute(a))return a;const i=t.fetcher.getLocalPath(r,t);return null===i?null:o.ppath.resolve(i,a)}async fetch(e,t){const r=t.checksums.get(e.locatorHash)||null,[a,o,s]=await t.cache.fetchPackageFromCache(e,r,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e),loader:()=>this.fetchFromDisk(e,t)});return{packageFs:a,releaseFs:o,prefixPath:n.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:s}}async fetchFromDisk(e,t){const r=await p(e.reference,s,t);return o.xfs.mktempPromise(async a=>{const s=o.ppath.join(a,Object(o.toFilename)("generator.js"));return await o.xfs.writeFilePromise(s,r),o.xfs.mktempPromise(async r=>{if(await this.generatePackage(r,e,s,t),!o.xfs.existsSync(o.ppath.join(r,Object(o.toFilename)("build"))))throw new Error("The script should have generated a build directory");return await n.tgzUtils.makeArchiveFromDirectory(o.ppath.join(r,Object(o.toFilename)("build")),{prefixPath:n.structUtils.getIdentVendorPath(e),compressionLevel:t.project.configuration.get("compressionLevel")})})})}async generatePackage(e,t,r,a){return await o.xfs.mktempPromise(async s=>{const i=await n.scriptUtils.makeScriptEnv({project:a.project,binFolder:s}),c=o.ppath.join(e,"runtime.js");return await o.xfs.mktempPromise(async a=>{const s=o.ppath.join(a,"buildfile.log"),l=o.xfs.createWriteStream(s),p=l,u=o.ppath.join(e,"generator"),f=o.ppath.join(e,"build");await o.xfs.mkdirPromise(u),await o.xfs.mkdirPromise(f);const h={tempDir:o.npath.fromPortablePath(u),buildDir:o.npath.fromPortablePath(f),locator:n.structUtils.stringifyLocator(t)};await o.xfs.writeFilePromise(c,`\n          // Expose 'Module' as a global variable\n          Object.defineProperty(global, 'Module', {\n            get: () => require('module'),\n            configurable: true,\n            enumerable: false,\n          });\n\n          // Expose non-hidden built-in modules as global variables\n          for (const name of Module.builtinModules.filter((name) => name !== 'module' && !name.startsWith('_'))) {\n            Object.defineProperty(global, name, {\n              get: () => require(name),\n              configurable: true,\n              enumerable: false,\n            });\n          }\n\n          // Expose the 'execEnv' global variable\n          Object.defineProperty(global, 'execEnv', {\n            value: {\n              ...${JSON.stringify(h)},\n            },\n            enumerable: true,\n          });\n        `);let d=i.NODE_OPTIONS||"";d=d.replace(/\s*--require\s+\S*\.pnp\.c?js\s*/g," ").trim(),i.NODE_OPTIONS=d,l.write(`# This file contains the result of Yarn generating a package (${n.structUtils.stringifyLocator(t)})\n`),l.write("\n");const{code:g}=await n.execUtils.pipevp(process.execPath,["--require",o.npath.fromPortablePath(c),o.npath.fromPortablePath(r),n.structUtils.stringifyIdent(t)],{cwd:e,env:i,stdin:null,stdout:l,stderr:p});if(0!==g)throw o.xfs.detachTemp(a),new Error(`Package generation failed (exit code ${g}, logs can be found here: ${s})`)})})}}],resolvers:[class{supportsDescriptor(e,t){return!!e.range.startsWith(s)}supportsLocator(e,t){return!!e.reference.startsWith(s)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,r){return n.structUtils.bindDescriptor(e,{locator:n.structUtils.stringifyLocator(t)})}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,r){if(!r.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");const{path:a,parentLocator:o}=i(e.range),c=await p(n.structUtils.makeRange({protocol:s,source:a,selector:a,params:{locator:n.structUtils.stringifyLocator(o)}}),s,r.fetchOptions);return[l(e,{parentLocator:o,path:a,generatorHash:n.hashUtils.makeHash(`${u}`,c).slice(0,6),protocol:s})]}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");const r=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),a=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(r.prefixPath,{baseFs:r.packageFs}),r.releaseFs);return{...e,version:a.version||"0.0.0",languageName:t.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.HARD,dependencies:a.dependencies,peerDependencies:a.peerDependencies,dependenciesMeta:a.dependenciesMeta,peerDependenciesMeta:a.peerDependenciesMeta,bin:a.bin}}}]};t.default=f}])}};