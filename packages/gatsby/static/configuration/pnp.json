{
  "title": "JSON Schema for Node.js Plug'n'Play data files",
  "$schema": "https://json-schema.org/draft/2019-09/schema#",
  "description": "The Plug'n'Play data files contains the set of packages used within a project, and their dependencies.",
  "__info": [
    "The following document describes the content of the .pnp.data.json files Yarn generates",
    "when the `pnpEnableInlining` setting is set to `false`."
  ],
  "type": "object",
  "properties": {
    "__info": {
      "description": "An array of arbitrary strings; only used as a header field to give some context to Yarn users.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "exampleItems": [
        "This file is automatically generated. Do not touch it, or risk",
        "your modifications being lost."
      ]
    },
    "dependencyTreeRoots": {
      "description": "A list of package locators that are roots of the dependency tree. There will typically be one entry for each workspace in the project (always at least one, as the top-level package is a workspace by itself).",
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "pattern": "^(?:@([^/]+?)/)?([^/]+?)$",
            "examples": ["@app/name"]
          },
          "reference": {
            "type": "string",
            "examples": ["workspace:."]
          }
        }
      },
      "exampleItems": [
        {"name": "@app/monorepo", "reference": "workspace:."},
        {"name": "@app/website", "reference": "workspace:website"}
      ]
    },
    "ignorePatternData": {
      "description": "A nullable regexp. If set, all project-relative importer paths should be matched against it. If the match succeeds, the resolution should follow the classic Node.js resolution algorithm rather than the Plug'n'Play one. Note that unlike other paths in the manifest, the one checked against this regexp won't begin by `./`.",
      "type": "string",
      "examples": ["^examples(/|$)"]
    },
    "enableTopLevelFallback": {
      "description": "If true, should a dependency resolution fail for an importer that isn't explicitly listed in `fallbackExclusionList`, the runtime must first check whether the resolution would succeed for any of the packages in `fallbackPool`; if it would, transparently return this resolution. Note that all dependencies from the top-level package are implicitly part of the fallback pool, even if not listed here.",
      "type": "boolean",
      "examples": [true]
    },
    "fallbackPool": {
      "description": "A map of locators that all packages are allowed to access, regardless whether they list them in their dependencies or not.",
      "type": "array",
      "items": {
        "type": "array",
        "prefixItems": [{
          "type": "string",
          "pattern": "^(?:@([^/]+?)/)?([^/]+?)$",
          "examples": ["@app/name"]
        }, {
          "type": "string",
          "foldStyle": false,
          "examples": ["workspace:."]
        }]
      },
      "exampleItems": [
        ["@app/monorepo", "workspace:."]
      ]
    },
    "fallbackExclusionList": {
      "description": "A map of packages that must never use the fallback logic, even when enabled. Keys are the package idents, values are sets of references. Combining the ident with each individual reference yields the set of affected locators.",
      "type": "array",
      "items": {
        "type": "array",
        "prefixItems": [{
          "type": "string"
        }, {
          "type": "array",
          "foldStyle": false,
          "items": {
            "type": "string"
          }
        }]
      },
      "exampleItems": [
        ["@app/server", ["workspace:sources/server"]]
      ]
    },
    "packageRegistryData": {
      "description": "This is the main part of the PnP data file. This table contains the list of all packages, first keyed by package ident then by package reference. One entry will have `null` in both fields and represents the absolute top-level package.",
      "type": "array",
      "foldStyle": true,
      "items": {
        "type": "array",
        "foldStyle": false,
        "prefixItems": [{
          "type": "string"
        }, {
          "type": "array",
          "foldStyle": true,
          "items": {
            "type": "array",
            "foldStyle": false,
            "prefixItems": [{
              "type": "string"
            }, {
              "type": "object",
              "properties": {
                "packageLocation": {
                  "description": "The location of the package on disk, relative to the Plug'n'Play manifest. This path must begin by either `./` or `../`, and must end with a trailing `/`.",
                  "type": "string"
                },
                "packageDependencies": {
                  "description": "The set of dependencies that the package is allowed to access. Each entry is a tuple where the first key is a package name, and the value a package reference. Note that this reference may be null! This only happens when a peer dependency is missing.",
                  "type": "array",
                  "foldStyle": true,
                  "items": {
                    "type": "array",
                    "foldStyle": false,
                    "prefixItems": [{
                      "type": "string"
                    }, {
                      "type": "string"
                    }]
                  }
                },
                "linkType": {
                  "description": "Can be either SOFT, or HARD. Hard package links are the most common, and mean that the target location is fully owned by the package manager. Soft links, on the other hand, typically point to arbitrary user-defined locations on disk.\nThe link type shouldn't matter much for most implementors - it's only needed because of some subtleties involved in turning a Plug'n'Play tree into a node_modules one.",
                  "type": "string",
                  "enum": ["SOFT", "HARD"]
                },
                "discardFromLookup": {
                  "description": "If true, this optional field indicates that the package must not be considered when the Plug'n'Play runtime tries to figure out the package that contains a given path. This is for instance what we use when using the `link:` protocol, as they often point to subfolders of a package, not to other packages.",
                  "type": "boolean"
                },
                "packagePeers": {
                  "description": "A list of packages that are peer dependencies. Just like `linkType`, this field isn't used by the Plug'n'Play runtime itself, but only by tools that may want to leverage the data file to create a node_modules folder.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }]
          }
        }]
      },
      "exampleItems": [
        [null, [
          [null, {
            "packageLocation": "./",
            "packageDependencies": [
              ["react", "npm:18.0.0"]
            ],
            "packagePeers": [],
            "linkType": "SOFT",
            "discardFromLookup": false
          }]
        ]],
        ["react", [
          ["npm:18.0.0", {
            "packageLocation": "./.yarn/cache/react-npm-18.0.0-a0b1c2d3.zip",
            "packageDependencies": [
              ["react-dom", null]
            ],
            "packagePeers": [
              "react-dom"
            ],
            "linkType": "HARD",
            "discardFromLookup": false
          }]
        ]]
      ]
    }
  }
}
