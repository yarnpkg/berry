module.exports={name:"@yarnpkg/plugin-workspace-tools",factory:function(e){return function(e){var t={};function o(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,o),a.l=!0,a.exports}return o.m=e,o.c=t,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)o.d(n,a,function(t){return e[t]}.bind(null,a));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=7)}([function(t,o){t.exports=e("@yarnpkg/core")},function(t,o){t.exports=e("clipanion")},function(t,o){t.exports=e("@yarnpkg/cli")},function(t,o){t.exports=e("yup")},function(t,o){t.exports=e("os")},function(e,t,o){"use strict";const n=o(6),a=e=>{if(e<1)throw new TypeError("Expected `concurrency` to be a number from 1 and up");const t=[];let o=0;const a=()=>{o--,t.length>0&&t.shift()()},r=(e,t,...r)=>{o++;const s=n(e,...r);t(s),s.then(a,a)},s=(n,...a)=>new Promise(s=>((n,a,...s)=>{o<e?r(n,a,...s):t.push(r.bind(null,n,a,...s))})(n,s,...a));return Object.defineProperties(s,{activeCount:{get:()=>o},pendingCount:{get:()=>t.length}}),s};e.exports=a,e.exports.default=a},function(e,t,o){"use strict";e.exports=(e,...t)=>new Promise(o=>{o(e(...t))})},function(e,t,o){"use strict";o.r(t);function n(e,t,o,n){var a,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,o):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,o,n);else for(var i=e.length-1;i>=0;i--)(a=e[i])&&(s=(r<3?a(s):r>3?a(t,o,s):a(t,o))||s);return r>3&&s&&Object.defineProperty(t,o,s),s}var a=o(2),r=o(0),s=o(1);class i extends a.BaseCommand{constructor(){super(...arguments),this.workspaces=[],this.json=!1,this.production=!1}async execute(){const e=await r.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:o}=await r.Project.find(e,this.context.cwd),n=await r.Cache.find(e);let s;if(0===this.workspaces.length){if(!o)throw new a.WorkspaceRequiredError(t.cwd,this.context.cwd);s=new Set([o])}else s=new Set(this.workspaces.map(e=>t.getWorkspaceByIdent(r.structUtils.parseIdent(e))));for(const e of s)for(const o of r.Manifest.hardDependencies)for(const n of e.manifest.getForScope(o).values()){const e=t.tryWorkspaceByDescriptor(n);null!==e&&s.add(e)}for(const e of t.workspaces)s.has(e)?this.production&&e.manifest.devDependencies.clear():(e.manifest.dependencies.clear(),e.manifest.devDependencies.clear(),e.manifest.peerDependencies.clear());return(await r.StreamReport.start({configuration:e,json:this.json,stdout:this.context.stdout,includeLogs:!0},async e=>{await t.install({cache:n,report:e,persistProject:!1}),await t.persistInstallStateFile()})).exitCode()}}i.usage=s.Command.Usage({category:"Workspace-related commands",description:"install a single workspace and its dependencies",details:"\n      This command will run an install as if the specified workspaces (and all other workspaces they depend on) were the only ones in the project. If no workspaces are explicitly listed, the active one will be assumed.\n\n      Note that this command is only very moderately useful when using zero-installs, since the cache will contain all the packages anyway - meaning that the only difference between a full install and a focused install would just be a few extra lines in the `.pnp.js` file, at the cost of introducing an extra complexity.\n\n      If the `--production` flag is set, only regular dependencies will be installed, and dev dependencies will be omitted.\n\n      If the `--json` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).\n    "}),n([s.Command.Rest()],i.prototype,"workspaces",void 0),n([s.Command.Boolean("--json")],i.prototype,"json",void 0),n([s.Command.Boolean("--production")],i.prototype,"production",void 0),n([s.Command.Path("workspaces","focus")],i.prototype,"execute",null);var c=o(4),l=o(5),d=o.n(l),p=o(3);const u=(e,t)=>{const o=[];for(const n of e.workspacesCwds){const e=t.workspacesByCwd.get(n);e&&o.push(e,...u(e,t))}return o};class h extends a.BaseCommand{constructor(){super(...arguments),this.args=[],this.all=!1,this.verbose=!1,this.parallel=!1,this.interlaced=!1,this.topological=!1,this.topologicalDev=!1,this.include=[],this.exclude=[],this.private=!0}async execute(){const e=await r.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:o}=await r.Project.find(e,this.context.cwd);if(!this.all&&!o)throw new a.WorkspaceRequiredError(t.cwd,this.context.cwd);const n=this.cli.process([this.commandName,...this.args]),i=1===n.path.length&&"run"===n.path[0]&&void 0!==n.scriptName?n.scriptName:null;if(0===n.path.length)throw new s.UsageError("Invalid subcommand name for iteration - use the 'run' keyword if you wish to execute a script");const l=this.all?t.topLevelWorkspace:o,p=[l,...u(l,t)],h=[];for(const e of p)i&&!e.manifest.scripts.has(i)||i===process.env.npm_lifecycle_event&&e.cwd===o.cwd||this.include.length>0&&!this.include.includes(r.structUtils.stringifyIdent(e.locator))||this.exclude.length>0&&this.exclude.includes(r.structUtils.stringifyIdent(e.locator))||!1===this.private&&!0===e.manifest.private||h.push(e);let m=this.interlaced;this.parallel||(m=!0);const w=new Map,g=new Set,y=this.parallel?Math.max(1,Object(c.cpus)().length/2):1,b=d()(this.jobs||y);let v=0,x=null;const k=await r.StreamReport.start({configuration:e,stdout:this.context.stdout},async o=>{const n=async(t,{commandIndex:n})=>{!this.parallel&&this.verbose&&n>1&&o.reportSeparator();const a=function(e,{configuration:t,commandIndex:o,verbose:n}){if(!n)return null;const a=r.structUtils.convertToIdent(e.locator),s=`[${r.structUtils.stringifyIdent(a)}]:`,i=["#2E86AB","#A23B72","#F18F01","#C73E1D","#CCE2A3"],c=i[o%i.length];return t.format(s,c)}(t,{configuration:e,verbose:this.verbose,commandIndex:n}),[s,i]=f(o,{prefix:a,interlaced:m}),[c,l]=f(o,{prefix:a,interlaced:m});try{const e=await this.cli.run([this.commandName,...this.args],{cwd:t.cwd,stdout:s,stderr:c})||0;s.end(),c.end();const n=await i,r=await l;return this.verbose&&n&&r&&o.reportInfo(null,`${a} Process exited without output (exit code ${e})`),e}catch(e){throw s.end(),c.end(),await i,await l,e}};for(const e of h)w.set(e.anchoredLocator.locatorHash,e);for(;w.size>0&&!o.hasErrors();){const a=[];for(const[e,o]of w){if(g.has(o.anchoredDescriptor.descriptorHash))continue;let r=!0;if(this.topological||this.topologicalDev){const e=this.topologicalDev?new Map([...o.manifest.dependencies,...o.manifest.devDependencies]):o.manifest.dependencies;for(const o of e.values()){const e=t.tryWorkspaceByDescriptor(o);if(!(r=null===e||!w.has(e.anchoredLocator.locatorHash)))break}}if(r&&(g.add(o.anchoredDescriptor.descriptorHash),a.push(b(async()=>{const t=await n(o,{commandIndex:++v});return w.delete(e),g.delete(o.anchoredDescriptor.descriptorHash),t})),!this.parallel))break}if(0===a.length){const t=Array.from(w.values()).map(t=>r.structUtils.prettyLocator(e,t.anchoredLocator)).join(", ");return void o.reportError(r.MessageName.CYCLIC_DEPENDENCIES,`Dependency cycle detected (${t})`)}const s=(await Promise.all(a)).find(e=>0!==e);x=void 0!==s?1:x,(this.topological||this.topologicalDev)&&void 0!==s&&o.reportError(r.MessageName.UNNAMED,"The command failed for workspaces that are depended upon by other workspaces; can't satisfy the dependency graph")}});return null!==x?x:k.exitCode()}}function f(e,{prefix:t,interlaced:o}){const n=e.createStreamReporter(t),a=new r.miscUtils.DefaultStream;a.pipe(n,{end:!1}),a.on("finish",()=>{n.end()});const s=new Promise(e=>{n.on("finish",()=>{e(a.active)})});if(o)return[a,s];const i=new r.miscUtils.BufferStream;return i.pipe(a,{end:!1}),i.on("finish",()=>{a.end()}),[i,s]}h.schema=p.object().shape({jobs:p.number().min(2),parallel:p.boolean().when("jobs",{is:e=>e>1,then:p.boolean().oneOf([!0],"--parallel must be set when using --jobs"),otherwise:p.boolean()})}),h.usage=s.Command.Usage({category:"Workspace-related commands",description:"run a command on all workspaces",details:"\n      This command will run a given sub-command on current and all its descendant workspaces. Various flags can alter the exact behavior of the command:\n\n      - If `-p,--parallel` is set, the commands will be ran in parallel; they'll by default be limited to a number of parallel tasks roughly equal to half your core number, but that can be overridden via `-j,--jobs`.\n\n      - If `-p,--parallel` and `-i,--interlaced` are both set, Yarn will print the lines from the output as it receives them. If `-i,--interlaced` wasn't set, it would instead buffer the output from each process and print the resulting buffers only after their source processes have exited.\n\n      - If `-t,--topological` is set, Yarn will only run the command after all workspaces that depend on it through the `dependencies` field have successfully finished executing. If `--topological-dev` is set, both the `dependencies` and `devDependencies` fields will be considered when figuring out the wait points.\n\n      - If `--all` is set, Yarn will run the command on all the workspaces of a project. By default yarn runs the command only on current and all its descendant workspaces.\n\n      - The command may apply to only some workspaces through the use of `--include` which acts as a whitelist. The `--exclude` flag will do the opposite and will be a list of packages that mustn't execute the script.\n\n      Adding the `-v,--verbose` flag will cause Yarn to print more information; in particular the name of the workspace that generated the output will be printed at the front of each line.\n\n      If the command is `run` and the script being run does not exist the child workspace will be skipped without error.\n    ",examples:[["Publish current and all descendant packages","yarn workspaces foreach npm publish --tolerate-republish"],["Run build script on current and all descendant packages","yarn workspaces foreach run build"],["Run build script on current and all descendant packages in parallel, building dependent packages first","yarn workspaces foreach -pt run build"]]}),n([s.Command.String()],h.prototype,"commandName",void 0),n([s.Command.Proxy()],h.prototype,"args",void 0),n([s.Command.Boolean("-a,--all")],h.prototype,"all",void 0),n([s.Command.Boolean("-v,--verbose")],h.prototype,"verbose",void 0),n([s.Command.Boolean("-p,--parallel")],h.prototype,"parallel",void 0),n([s.Command.Boolean("-i,--interlaced")],h.prototype,"interlaced",void 0),n([s.Command.String("-j,--jobs")],h.prototype,"jobs",void 0),n([s.Command.Boolean("-t,--topological")],h.prototype,"topological",void 0),n([s.Command.Boolean("--topological-dev")],h.prototype,"topologicalDev",void 0),n([s.Command.Array("--include")],h.prototype,"include",void 0),n([s.Command.Array("--exclude")],h.prototype,"exclude",void 0),n([s.Command.Boolean("--private")],h.prototype,"private",void 0),n([s.Command.Path("workspaces","foreach")],h.prototype,"execute",null);const m={commands:[i,h]};t.default=m}])}};