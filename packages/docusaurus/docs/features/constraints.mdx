---
category: features
slug: /features/constraints
title: "Constraints"
description: An in-depth guide to Yarn's constraints, a feature that provides an easy way to enforce common rules across a project.
---

:::info
This page documents the new JavaScript-based constraints. The older constraints, based on Prolog, are still supported but should be considered deprecated. Their documentation can be found [here](https://v3.yarnpkg.com/features/constraints).
:::

## Overview

Constraints allow enforcement of rules across [workspace](/features/workspaces) packages. For example, these rules might include the following:

* Ensuring the same version of dependencies across packages.
* Prohibiting the use of specific dependencies in packages.

## What can we enforce?

Our constraint engine currently supports two main targets:

- Workspace dependencies
- Arbitrary package.json fields

It currently doesn't support the following, but might in the future (PRs welcome!):

- Transitive dependencies
- Project structure

## Creating a constraint

Constraints are created by adding a `yarn.config.cjs` file at the root of your project (repository). This file should export an object with a `constraints` method. This method will be called by the constraints engine, and must define the rules to enforce on the project, using the provided API.

For example, the following `yarn.config.cjs` will enforce that all `react` dependencies are set to `18.0.0`.

```ts
module.exports = {
  async constraints({Yarn}) {
    for (const dep of Yarn.dependencies({ ident: 'react' })) {
      dep.update(`18.0.0`);
    }
  },
};
```

And the following will enforce that the `engines.node` field is properly set in all workspaces:

```ts
module.exports = {
  async constraints({Yarn}) {
    for (const workspace of Yarn.workspaces()) {
      workspace.set('engines.node', `20.0.0`);
    }
  },
};
```

## Declarative model

As much as possible, constraints are defined using a declarative model: you declare what the expected state should be, and Yarn checks whether it matches the reality or not. If it doesn't, Yarn will either throw an error (when calling `yarn constraints` without arguments), or attempt to automatically fix the issue (when calling `yarn constraints --fix`).

Because of this declarative model, you don't need to check the actual values yourself. For instance, the `if` condition here is extraneous and should be removed:

```ts
module.exports = {
  async constraints({Yarn}) {
    for (const dep of Yarn.dependencies({ ident: 'ts-node' })) {
      // No need to check for the actual value! Just always call `update`.
      if (dep.range !== `18.0.0`) {
        dep.update(`18.0.0`);
      }
    }
  },
};
```

## TypeScript support

Yarn ships types that make it easier to write constraints. To use them, add the dependency to your project:

```
$ yarn add @yarnpkg/types
```

Then, in your `yarn.config.cjs` file, import the types, in particular the `defineConfig` function which automatically type the configuration methods:

```ts
/** @type {import('@yarnpkg/types')} */
const { defineConfig } = require('@yarnpkg/types');

module.exports = defineConfig({
  async constraints({Yarn}) {
    // `Yarn` is now well-typed âœ¨
  },
});
```

You can also retrieve the types manually, which can be useful if you extract some rules into helper functions:

```ts
/** @param {import('@yarnpkg/types').Yarn.Constraints.Workspace} dependency */
function expectMyCustomRule(dependency) {
  // ...
}
```

You can alias the types to make them a little easier to use:

```ts
/**
 * @typedef {import('@yarnpkg/types').Yarn.Constraints.Workspace} Workspace
 * @typedef {import('@yarnpkg/types').Yarn.Constraints.Dependency} Dependency
 */

/** @param {Workspace} dependency */
function expectMyCustomRule(dependency) {
  // ...
}
```

## Putting it all together

This section regroups a couple of constraint examples. We are thinking to provide some of them as builtin helpers later on, although they tend to often contain some logic unique to each team / company.

### Restrict dependencies between workspaces

Require that if two workspaces have the same dependency, the greater version must be used in both.  This ensures
dependencies are kept in sync.  Because this only corrects to a newer version you can use `yarn constraints --fix`
to automatically correct the mismatches.

```ts
// @ts-check

/** @type {import('@yarnpkg/types')} */
const { defineConfig } = require('@yarnpkg/types');
const semver = require('semver');

// If otherRange is a greater version, return it.  Otherwise return range.
function preferredRange(range, otherRange) {
  if (otherRange === '*') {
    return range;
  }
  const version = semver.coerce(range);
  const otherVersion = semver.coerce(otherRange);
  if (
    version && otherVersion && !semver.eq(version, otherVersion)
      ? semver.gt(otherVersion, version)
      : range.localeCompare(otherRange) > 0
  ) {
    return otherRange;
  }
  return range;
}

// Require that if two workspaces have the same dependency, the greater version must be used in both.
function enforceConsistentDependencies(Yarn) {
  // Force consistent dependency versions of all dependencies and devDependencies
  for (const dependency of Yarn.dependencies()) {
    for (const otherDependency of Yarn.dependencies({
      ident: dependency.ident,
    })) {
      if (dependency.range !== otherDependency.range) {
        dependency.update(
          preferredRange(dependency.range, otherDependency.range),
        );
      }
    }
  }
}

module.exports = defineConfig({
  async constraints({ Yarn }) {
    enforceConsistentDependencies(Yarn);
  },
});

```

### Prevent multiple virtual instances of packages

Having multiple instances can break many popular packages like react-dom, styled-components, and so on.
This constraint enforces that peer dependencies of packages are satisfied in the same way, so that there
will only be a single instance.  To allow packages to have multiple instances, add them to the
multipleInstancesWhitelist array.

```ts
// @ts-check

/** @type {import('@yarnpkg/types')} */
const { defineConfig } = require('@yarnpkg/types');
const semver = require('semver');

// If otherRange is a greater version, return it.  Otherwise return range.
function preferredRange(range, otherRange) {
  if (otherRange === '*') {
    return range;
  }
  const version = semver.coerce(range);
  const otherVersion = semver.coerce(otherRange);
  if (
    version && otherVersion && !semver.eq(version, otherVersion)
      ? semver.gt(otherVersion, version)
      : range.localeCompare(otherRange) > 0
  ) {
    return otherRange;
  }
  return range;
}

// Having multiple instances can break many popular packages like react-dom, styled-components, and so on.
// This constraint enforces that peer dependencies of packages are satisfied in the same way, so that there
// will only be a single instance.  To allow packages to have multiple instances, add them to the
// multipleInstancesWhitelist list here.
const multipleInstancesWhitelist = [
  'debug',
  'isomorphic-ws',
  /^@babel/,
  /^@types/,
];
function enforceSingletonPackagesWithPeerDependencies(Yarn) {
  // Whitelist deps we don't mind having multiple instances
  // Force all dependencies to be singletons
  const inverseDepTree = new Map();
  const walked = new Set();
  for (const dependency of Yarn.dependencies()) {
    // We don't consider duplicate dev dependencies to be an issue; only multiple instances
    // of regular or peer dependencies cause problems
    if (dependency.type === 'devDependencies') {
      continue;
    }
    // Can't do much if the dependency failed to resolve
    if (!dependency.resolution) {
      continue;
    }
    const inverseDepNode = package => {
      const existing = inverseDepTree.get(package.ident);
      if (existing) {
        return existing;
      }
      const result = {
        dependents: new Map(),
        workspace: dependency.workspace,
        package,
      };
      inverseDepTree.set(package.ident, result);
      return result;
    };

    const walk = package => {
      if (walked.has(package.ident)) {
        return;
      }
      walked.add(package.ident);
      for (const depPkg of package.dependencies.values()) {
        // Don't register a dependency for this purpose if it's a peer dependency.  Only direct
        // dependencies cause problems
        if (
          package.peerDependencies.has(depPkg.ident) ||
          package.optionalPeerDependencies.has(depPkg.ident)
        ) {
          continue;
        }
        if (
          depPkg.peerDependencies.size &&
          !multipleInstancesWhitelist.some(pattern =>
            typeof pattern === 'string'
              ? depPkg.ident === pattern
              : pattern instanceof RegExp
                ? pattern.test(depPkg.ident)
                : false,
          )
        ) {
          const node = inverseDepNode(depPkg);
          node.dependents.set(package.ident, package);
        }
        walk(depPkg);
      }
    };

    walk(dependency.resolution);
  }

  for (const { package, dependents, workspace } of inverseDepTree.values()) {
    if (dependents.size > 1) {
      const peerDeps = [...new Set([...package.peerDependencies.keys()])].map(
        peerDep => ({
          ident: peerDep,
          providedVersions: new Map(),
        }),
      );
      for (const dependent of dependents.values()) {
        for (const { ident, providedVersions } of peerDeps) {
          const providedVersion =
            dependent.dependencies.get(ident)?.version ||
            dependent.peerDependencies.get(ident) ||
            dependent.optionalPeerDependencies.get(ident) ||
            (dependent.ident === ident ? dependent.version : null) ||
            'none';
          const versionProviders = providedVersions.get(providedVersion);
          const dependentId = `${dependent.ident}@${dependent.version}`;
          if (!versionProviders) {
            providedVersions.set(
              providedVersion,
              new Map([[dependentId, dependent]]),
            );
          } else {
            versionProviders.set(dependentId, dependent);
          }
        }
      }
      for (const peerDep of peerDeps) {
        if (peerDep.providedVersions.size > 1) {
          // Pick the target range that should be provided, and assert that all dependents should
          // have provided a dependency with that version.
          const bestVersion = [...peerDep.providedVersions.keys()]
            .filter(r => r !== '*' && r !== 'none')
            .reduce((a, b) => preferredRange(b, a), '*');
          const wrongVersionProviders = new Map(peerDep.providedVersions);
          wrongVersionProviders.delete(bestVersion);
          for (const [
            providedVersion,
            providersMap,
          ] of wrongVersionProviders.entries()) {
            for (const dependent of providersMap.values()) {
              (dependent.workspace || workspace).error(
                [
                  dependent.workspace ? 'Package' : dependent.ident,
                  providedVersion === 'none'
                    ? `does not provide ${peerDep.ident}`
                    : `provides ${peerDep.ident}@${providedVersion}`,
                  `while other packages provide "${bestVersion}".`,
                  `This could result in multiple instances of ${package.ident}.`,
                  `Run "yarn info --all --dependents --virtuals --recursive ${package.ident}" for details.`,
                ].join(' '),
              );
              if (dependent.workspace) {
                // If the dependent has peer dependencies then propagate/satisfy the peer dependency using
                // devDependencies/peerDependencies.  Otherwise put as the same kind of dependency.
                if (dependent.peerDependencies.size) {
                  for (const depType of [
                    'devDependencies',
                    'peerDependencies',
                  ]) {
                    dependent.workspace.set(
                      [depType, peerDep.ident],
                      bestVersion,
                    );
                  }
                } else {
                  for (const packageWorkspaceDep of Yarn.dependencies({
                    workspace: dependent.workspace,
                    ident: package.ident,
                  })) {
                    dependent.workspace.set(
                      [packageWorkspaceDep.type, peerDep.ident],
                      bestVersion,
                    );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
module.exports = defineConfig({
  async constraints({ Yarn }) {
    enforceSingletonPackagesWithPeerDependencies(Yarn);
  },
});

```
