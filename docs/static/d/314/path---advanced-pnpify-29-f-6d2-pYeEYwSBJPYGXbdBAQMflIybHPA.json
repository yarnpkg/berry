{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/advanced/architecture","title":"Architecture"}}},{"node":{"frontmatter":{"path":"/advanced/contributing","title":"Contributing"}}},{"node":{"frontmatter":{"path":"/advanced/error-codes","title":"Error Codes"}}},{"node":{"frontmatter":{"path":"/advanced/lexicon","title":"Lexicon"}}},{"node":{"frontmatter":{"path":"/advanced/migration","title":"Migration"}}},{"node":{"frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}},{"node":{"frontmatter":{"path":"/advanced/pnpify","title":"Pnpify"}}}]},"markdownRemark":{"html":"<h2 id=\"motivation\"><a href=\"#motivation\" aria-label=\"motivation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Motivation</h2>\n<p>Plug'n'Play is, by design, compatible with all projects that only make use of the <code>require</code> API - whether it's <code>require</code> <code>require.resolve</code>, or <code>createRequireFromPath</code>. However, some projects like to reimplement the resolution themselves and aren't compatible by default with Plug'n'Play environments (unless they add some specific logic into their resolution). One such project is for example TypeScript, which doesn't natively supports Plug'n'Play yet in its <code>tsc</code> binary.</p>\n<h2 id=\"pnpify\"><a href=\"#pnpify\" aria-label=\"pnpify permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PnPify</h2>\n<p>PnPify is a tool designed to workaround this compatibility problem. It's not a perfect solution in that it brings its own set of caveats, but it's often good enough for most use cases. How it works is simple: when a non-PnP compliant project tries to access the <code>node_modules</code> directories (for example through <code>readdir</code> or <code>readFile</code>), PnPify intercepts those calls and converts them into calls to the PnP API. Then, based on the result, it simulates an actual filesystem for the underlying tool to use.</p>\n<h2 id=\"usage\"><a href=\"#usage\" aria-label=\"usage permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usage</h2>\n<p>Add PnPify to your dependencies:</p>\n<pre><code>$> yarn add @berry/pnpify\n</code></pre>\n<p>Use pnpify to run the incompatible tool:</p>\n<pre><code>$> yarn pnpify tsc\n</code></pre>\n<p>That's all!</p>\n<h2 id=\"caveat\"><a href=\"#caveat\" aria-label=\"caveat permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caveat</h2>\n<p>Because PnPify doesn't try to do any kind of hoisting, relying exclusively on its fake filesystem might lead to subtle performance issues where, amongst other issues, one package would be instantiated more times than would be needed otherwise. <strong>This is only a problem for bundlers like Webpack</strong>; tools like <code>tsc</code> don't suffer from it, because they only need to know about the structural file content and don't actually instantiate the files.</p>\n<p>If you want to use PnP with a bundler that doesn't natively support it, we currently recommend you to use the dedicated plugins that we've provided: <a href=\"https://github.com/arcanis/pnp-webpack-plugin\"><code>pnp-webpack-plugin</code></a> for Webpack, or <a href=\"https://github.com/arcanis/rollup-plugin-pnp-resolve\"><code>rollup-pnp-resolver</code></a> for Rollup. Those plugins use the PnP API as it is, and thus don't suffer from this optimization problem.</p>","frontmatter":{"path":"/advanced/pnpify","title":"Pnpify"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"advanced"}}