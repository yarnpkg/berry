{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/advanced/architecture","title":"Architecture"}}},{"node":{"frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}}]},"markdownRemark":{"html":"<p>The PnP linker guarantees that each combination of package name / version will only be instantiated once, except in one documented case: if a package has peer dependencies, then it will be instantiated once for each time a hard dependency is found in the dependency tree.</p>\n<p>For example, let's say you have <code>react</code> and <code>react-dom</code> - since the <code>react</code> package doesn't list peer dependencies, a same version of <code>react</code> will only ever be instantiated once, regardless how many dependent packages list it in their <code>dependencies</code> field. However, because <code>react-dom</code> lists <code>react</code> within its <code>peerDependencies</code> field, Yarn will need to install it in such a way that it will be instantiated exactly once for each package that list it in their <code>dependencies</code> field.</p>\n<h2>Why does it work this way?</h2>\n<p>Let's say you have <code>package-a</code> and <code>package-b</code>. Both of them depend on the same package <code>child</code>, which has a peer dependency on <code>peer</code>. Now, imagine that <code>package-a</code> depends on <code>peer@1</code> while <code>package-b</code> depends on <code>peer@2</code>. In this instance, in order to respect the peer dependency requirement, <code>child</code> will have to be instantiated - it wouldn't be possible otherwise for <code>child</code> to simultaneously use both <code>package-a</code> and <code>package-b</code>.</p>\n<p>In order to make sure that <code>child</code> will get instatiated twice, we generate what we call \"virtual packages\". A virtual packages simply is an additional instance of a package, that points to the same location on the disk but will have its own in-memory representation. In order to generate those virtual packages, we need them to give each of them a unique identifier. Now, what information could we use to do this?</p>\n<p>The first thing you might think of could be something along those lines: \"the unique identifier for a virtual package must be based on its set of inherited dependencies\". So in our example, since <code>child</code> has two sets of inherited dependencies, it would get two unique identifiers, would be instantiated twice, and everything would work. Additionally, if <code>package-a</code> and <code>package-b</code> happened to depend on the same version of <code>peer</code> then we would only generate one virtual package, which would decrease the tree complexity. Unfortunately, it's not so simple.</p>\n<p>Problems arise when you consider circular dependencies. Let's imagine a different scenario: <code>package</code> depends on <code>child-a</code> and <code>child-b</code>. The <code>child-a</code> package has a peer dependency on <code>child-b</code>, and <code>child-b</code> has a peer dependency on <code>child-a</code>. In this situation, per the wording described above, we would need to generate the unique identifier for <code>child-a</code> based on the set of its dependencies, which includes <code>child-b</code>. But since the unique identifier for <code>child-b</code> depends on the one from <code>child-a</code>, we cannot do that! The loop cannot be broken this way.</p>\n<p>The solution to this issue is to say that the unique identifier for a package with peer dependencies is based on the unique identifier of its <em>direct parent</em>. Since a package unique identifier is always computed before its children (which also happens to be the reason why peer dependencies must be explicitly listed at every level of the dependency hierarchy), we cannot have a cyclic dependency.</p>\n<h2>How to prevent multiple instantiation?</h2>\n<p>In some cases, you really don't want a package to be instantiated twice. It can be because you're using <code>instanceof</code> on user-provided objects (which would break for similar objects from different instances), or because your code has side effects (for example by having a singleton).</p>\n<p>In general we discourage the use of these patterns - they are quite dangerous, and it's hard to know for sure that your package will only be instantiated once. Still, it might also be difficult to change immediatly, so fortunately you have a few options:</p>\n<ul>\n<li>\n<p>You can move the code managing your singleton inside its own package. So for example in the case of <code>relay-runtime</code> (which has a singleton and a peer dependency on <code>relay-compiler</code>) the solution is to move the singleton into a dedicated package without the peer dependency on <code>relay-compiler</code>.</p>\n</li>\n<li>\n<p>Maybe simpler, your singleton can also be stored within the global context, using an identifier unique to your application. This would even be safer than what you can currently do, because you'd be able to properly check for multiple conflicting versions being used:</p>\n<pre><code>const myVersion = require('./package.json').version;\n\nfunction makeSingleton() {\n  return {\n    value: new Something(),\n    version: myVersion,\n  };\n}\n\nexport function getSingleton() {\n  if (!global.singleton)\n    global.singleton = makeSingleton();\n\n  const {value, version} = global.singleton;\n  console.assert(version === myVersion);\n\n  return value;\n}\n</code></pre>\n</li>\n</ul>","frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"advanced"}}