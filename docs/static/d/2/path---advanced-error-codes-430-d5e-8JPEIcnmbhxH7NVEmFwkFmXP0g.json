{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/advanced/architecture","title":"Architecture"}}},{"node":{"frontmatter":{"path":"/advanced/contributing","title":"Contributing"}}},{"node":{"frontmatter":{"path":"/advanced/error-codes","title":"Error Codes"}}},{"node":{"frontmatter":{"path":"/advanced/lexicon","title":"Lexicon"}}},{"node":{"frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}}]},"markdownRemark":{"html":"<!-- Never remove the entries in this file, as we want to support older releases -->\n<h2>BR0000 - <code>UNNAMED</code></h2>\n<p>This code is used to log regular messages, mostly to align all the lines in the Yarn output. No worry!</p>\n<h2>BR0001 - <code>EXCEPTION</code></h2>\n<p>An exception had be thrown by the program.</p>\n<p>This error typically should never happen (it should instead point to a different error message from this page so that it can be properly documented), so it should be considered a bug in Yarn. Feel free to open an issue or, even better, a pull request aiming to fix it.</p>\n<h2>BR0002 - <code>MISSING_PEER_DEPENDENCY</code></h2>\n<p>A package requests a peer dependency, but its parent in the dependency tree doesn't provide it.</p>\n<p>This error occurs when a package peer dependencies cannot be satisfied. If the peer dependency is optional and shouldn't trigger such warnings, then mark it as such using the <a href=\"\">optional peer dependencies</a> feature.</p>\n<p>Note that Yarn enforces peer dependencies at every level of the dependency tree - meaning that if <code>A</code> depends on <code>(B,X)</code> and <code>B</code> depends on <code>C</code> and <code>C</code> has a peer dependency on <code>X</code>, then a warning will be emitted (because <code>B</code> doesn't fulfill the peer dependendy request). The best way to solve this is to explicitly list the transitive peer dependency on <code>X</code> in <code>B</code> has well.</p>\n<h2>BR0003 - <code>CYCLIC_DEPENDENCIES</code></h2>\n<p>Two packages with build scripts have cyclic dependencies.</p>\n<p>Cyclic dependencies are a can of worm. They happen when a package <code>A</code> depends on a package <code>B</code> and vice-versa (they sometime can be spread across multiple packages - for example <code>A</code> depends on <code>B</code> which depends on <code>C</code> which depends on <code>A</code>).</p>\n<p>While they may work fine in the general case (and in fact Berry won't warn you about it in most cases), they cause issues as soon as build scripts are involved. Indeed, in order to build a package, we first must make sure that its own dependencies have been properly built. How can we do that when two packages reference each other? Since it cannot be deduced, such patterns will cause the build scripts of every affected packages to simply be ignored.</p>\n<p>There's already good documentation online explaining how to get rid of cyclic dependencies, the simplest one being to extract the shared part of your program into a third package without dependencies. So the first case we described would become <code>A</code> depends on <code>C</code>, <code>B</code> depends on <code>C</code>, <code>C</code> doesn't depend on anything.</p>\n<h2>BR0004 - <code>DISABLED_BUILD_SCRIPTS</code></h2>\n<p>A package has build scripts, but they've been disabled across the project.</p>\n<p>Build scripts can be disabled on a global basis through the use of the <code>enable-scripts</code> settings. When it happens, a warning is still emitted to let you know that the installation might not be complete.</p>\n<p>The safest way to downgrade the warning into a notification is to explicitly disable build scripts for the affected packages through the use of the <code>dependenciesMeta[].build</code> key.</p>\n<h2>BR0005 - <code>BUILD_DISABLED</code></h2>\n<p>A package has build scripts, but they've been disabled through its configuration.</p>\n<p>Build scripts can be disabled on a per-project basis through the use of the <code>dependenciesMeta</code> settings from the <code>package.json</code> file. When it happens, a notification is still emitted to let you know that the installation might not be complete.</p>\n<h2>BR0006 - <code>SOFT_LINK_BUILD</code></h2>\n<p>A package has build scripts, but is linked through a soft link.</p>\n<p>For Yarn, a hard link is when a package is owned by the package manager. In these instances Yarn will typically copy packages having build scripts into a project-local cache so that multiple projects with multiple dependency trees don't use the same build artifacts. So what's the problem with so-called \"soft links\"?</p>\n<p>Soft links are when the package manager doesn't own the package source. An example is a workspace, or a dependency referenced through the <code>portal:</code> specifier. In these instances Yarn cannot safely assume that executing build scripts there is the intended behavior, because it would likely involve mutating your project or, even worse, an external location on your disk that might be shared by multiple projects. Since Yarn avoids doing anything unsafe, it cannot run build scripts on soft links.</p>\n<p>There are a few workarounds:</p>\n<ul>\n<li>\n<p>Using <code>file:</code> instead of <code>portal:</code> will cause a hard link to be used instead of a soft link. The other side of the coin will be that the packages will be copied into the cache as well, meaning that changing the package source will require you to run <code>YARN_UPDATE_FILE_CACHE=1 yarn install</code> for your changes to be taken into account.</p>\n</li>\n<li>\n<p>You can manually run <code>yarn run postinstall</code> (or whatever is named your build script) from the directory of the affected packages. This requires you to know in which order they'll have to be called, but is generally the safest option.</p>\n</li>\n<li>\n<p>You can simply abstain from using build scripts with soft links. While this suggestion might seem like a bad case of \"fix a problem by not encountering the problem\", consider that build scripts in development might not be of the best effect from a developer experience perspective - they usually mean that you'll need to run a script before being able to see your changes, which is often not what you seek.</p>\n</li>\n</ul>\n<h2>BR0007 - <code>MUST_BUILD</code></h2>\n<p>A package must be built.</p>\n<p>This informational message occurs when Yarn wishes to let you know that a package will need to be built in order for the installation to complete. This usually occurs in only two cases: either the package never has been built before, or its previous build failed (returned a non-zero exit code).</p>\n<h2>BR0008 - <code>MUST_REBUILD</code></h2>\n<p>A package must be rebuilt.</p>\n<p>This information message occurs when Yarn wishes to let you know that a package will need to be rebuilt in order for the installation to complete. This usually occurs in a single case: when the package's dependency tree has changed. Note that this also include its transitive dependencies, which sometimes may cause surprising rebuilds (for example, if <code>A</code> depends on <code>B</code> that depends on <code>C@1</code>, and if Yarn decides for some reason that <code>C</code> should be bumped to <code>C@2</code>, then <code>A</code> will need to be rebuilt).</p>\n<h2>BR0009 - <code>BUILD_FAILED</code></h2>\n<p>A package build failed.</p>\n<p>This problem typically doesn't come from Yarn itself, and simply means that a package described as having build directives couldn't get built successfully.</p>\n<p>To see the actual error message, read the file linked in the report. It will contain the full output of the failing script.</p>\n<h2>BR0010 - <code>RESOLVER_NOT_FOUND</code></h2>\n<p>A resolver cannot be found for the given package.</p>\n<p>Resolvers are the components tasked from converting ranges (<code>^1.0.0</code>) into references (<code>1.2.3</code>). They each contain their own logic to do so - the semver resolver is the most famous one but far from being the only one. The GitHub resolver transforms GitHub repositories into tarball urls, the Git resolver normalizes the paths sent to git, ... each resolver takes care of a different resolution strategy. A missing resolver means that one of those strategies is missing.</p>\n<p>This error is usually caused by a Yarn plugin being missing.</p>\n<h2>BR0011 - <code>FETCHER_NOT_FOUND</code></h2>\n<p>A fetcher cannot be found for the given package.</p>\n<p>Fetchers are the components that take references and fetch the source code from the remote location. A semver fetcher would likely fetch the packages from some registry, while a workspace fetcher would simply redirect to the location on the disk where the sources can be found.</p>\n<p>This error is usually caused by a Yarn plugin being missing.</p>\n<h2>BR0012 - <code>LINKER_NOT_FOUND</code></h2>\n<p>A linker cannot be found for the given package.</p>\n<p>Linkers are the components tasked from extracting the sources from the artifacts returned by the fetchers and putting them on the disk in a manner that can be understood by the target environment. The Node linker would use the Plug'n'Play strategy, while a PHP linker would use an autoload strategy instead.</p>\n<p>This error is usually caused by a Yarn plugin being missing.</p>\n<h2>BR0013 - <code>FETCH_NOT_CACHED</code></h2>\n<h2>BR0014 - <code>YARN_IMPORT_FAILED</code></h2>\n<h2>BR0015 - <code>REMOTE_INVALID</code></h2>\n<h2>BR0016 - <code>REMOTE_NOT_FOUND</code></h2>\n<h2>BR0017 - <code>RESOLUTION_PACK</code></h2>\n<h2>BR0018 - <code>CACHE_CHECKSUM_MISMATCH</code></h2>\n<h2>BR0019 - <code>UNUSED_CACHE_ENTRY</code></h2>\n<h2>BR0020 - <code>MISSING_LOCKFILE_ENTRY</code></h2>\n<h2>BR0021 - <code>WORKSPACE_NOT_FOUND</code></h2>\n<h2>BR0022 - <code>TOO_MANY_MATCHING_WORKSPACES</code></h2>\n<h2>BR0023 - <code>CONSTRAINTS_MISSING_DEPENDENCY</code></h2>\n<h2>BR0024 - <code>CONSTRAINTS_INCOMPATIBLE_DEPENDENCY</code></h2>\n<h2>BR0025 - <code>CONSTRAINTS_EXTRANEOUS_DEPENDENCY</code></h2>\n<h2>BR0026 - <code>CONSTRAINTS_INVALID_DEPENDENCY</code></h2>\n<h2>BR0027 - <code>CANT_SUGGEST_RESOLUTIONS</code></h2>\n<h2>BR0028 - <code>FROZEN_LOCKFILE_EXCEPTION</code></h2>\n<h2>BR0029 - <code>CROSS_DRIVE_VIRTUAL_LOCAL</code></h2>\n<h2>BR0030 - <code>FETCH_FAILED</code></h2>\n<h2>BR0031 - <code>DANGEROUS_NODE_MODULES</code></h2>","frontmatter":{"path":"/advanced/error-codes","title":"Error Codes"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"advanced"}}