{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/features/offline-cache","title":"Offline Cache"}}},{"node":{"frontmatter":{"path":"/features/pnp","title":"Plug'n'Play"}}},{"node":{"frontmatter":{"path":"/features/plugins","title":"Plugins"}}},{"node":{"frontmatter":{"path":"/features/protocols","title":"Protocols"}}},{"node":{"frontmatter":{"path":"/features/workspaces","title":"Workspaces"}}},{"node":{"frontmatter":{"path":"/features/zero-installs","title":"Zero-Installs"}}}]},"markdownRemark":{"html":"<p>Initially designed to solve part of what <a href=\"https://github.com/lerna/lerna\">Lerna</a> used to do, Yarn's workspaces are a feature designed to make monorepos easy to use, solving one of the main use cases for <code>yarn link</code> in a more declarative way. In short, they allow multiple of your projects to live together in the same repository AND to cross-reference each others.</p>\n<p>First, some vocabulary: in the context of the workspace feature, a <em>project</em> is the whole directory tree making up your workspaces (often the repository itself). A <em>workspace</em> is a specific named package inside the project. Finally, a <em>worktree</em> is the name given to private packages that define new workspaces. A project may contains multiple worktrees, which may contain multiple workspaces.</p>\n<h2>How to declare a worktree?</h2>\n<p>Worktrees are defined via the use of a traditional <code>package.json</code> file. What makes them special is that they have the following properties:</p>\n<ul>\n<li>\n<p>They have to be marked <code>private: true</code>. We've designed this requirement because workspaces are a client-only feature. The remote registries (such as the npm registry) have no idea what a workspace is (nor should they do). In order to prevent accidental pushes and information leaks workspaces must have their private flag set.</p>\n</li>\n<li>\n<p>On top of being private, worktrees must declare a <code>workspaces</code> field which is an array of glob patterns that should be used to locate the workspaces that make up the worktree (for example if you want all folders within the <code>packages</code> folder to be workspaces, just add <code>workspaces/*</code> to this array).</p>\n</li>\n<li>\n<p>Finally, worktrees must be connected to the project-level <code>package.json</code> file. This doesn't matter in the typical workspace setup because there's usually a single worktree defined in the project-level <code>package.json</code>, but if you try to setup nested workspaces then you must make sure that the nested worktree is defined as a valid workspace of its parent worktree (otherwise Yarn won't find its correct parent folder).</p>\n</li>\n</ul>\n<p>Note that because worktrees are defined with an otherwise regular <code>package.json</code> file, they also are valid workspaces themselves. If they're named, other workspaces will be able to properly cross-reference them.</p>\n<h2>What does it mean to be a workspace?</h2>\n<p>Workspaces have two important properties:</p>\n<ul>\n<li>\n<p>Only the dependencies depended upon by a workspace can be accessed. Said another way, we strictly enforce your workspaces dependencies. Doing this allows to cleanly decouple projects from one another, since you don't have to merge all their dependencies in one huge unmaintainable list. We still provide tools to manage dependencies from multiple workspaces at once, but they need to be explicitly used and offer a better integration (for example <code>yarn add</code> can make suggestions for your new dependencies based on what other workspaces use, but you can override them).</p>\n</li>\n<li>\n<p>If the package manager was to resolve a range that a workspace could satisfy, it will prefer the workspace resolution over the remote resolution if possible. This is the pillar of the monorepo approach: rather than using the remote packages from the registry, your project packages will be interconnected and will use the code stored within your repository.</p>\n</li>\n</ul>\n<h2>Workspace ranges (<code>workspace:</code>)</h2>\n<p>While Yarn automatically picks workspace resolutions when they match, there are times where you absolutely don't want to risk using a package from the remote registry even if the versions don't match (for example if your project isn't actually meant to be published and you just want to use the workspaces to better compartiment your code).</p>\n<p>For those use cases, Yarn now supports a new resolution protocol starting from the v2: <code>workspace:</code>. When this protocol is used Yarn will refuse to resolve to anything else than a local workspace. This range protocol has two flavors:</p>\n<ul>\n<li>If a semver range, it will select the workspace matching the specified version.</li>\n<li>If a project-relative path, it will select the workspace that match this path <strong>(experimental)</strong>.</li>\n</ul>\n<p>Note that the second flavor is experimental and we advise against using it for now, as some details might change in the future. Our current recommendation is to use <code>workspace:*</code>, which will almost always do what you expect.</p>","frontmatter":{"path":"/features/workspaces","title":"Workspaces"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"features"}}