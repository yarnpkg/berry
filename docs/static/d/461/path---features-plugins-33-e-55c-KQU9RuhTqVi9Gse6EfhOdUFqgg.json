{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/features/offline-cache","title":"Offline Cache"}}},{"node":{"frontmatter":{"path":"/features/pnp","title":"Plug'n'Play"}}},{"node":{"frontmatter":{"path":"/features/plugins","title":"Plugins"}}},{"node":{"frontmatter":{"path":"/features/protocols","title":"Protocols"}}},{"node":{"frontmatter":{"path":"/features/workspaces","title":"Workspaces"}}},{"node":{"frontmatter":{"path":"/features/zero-installs","title":"Zero-Installs"}}}]},"markdownRemark":{"html":"<p>Ever since Yarn was created, our very essence has been experimenting. We wanted this project to break the status quo, then evolve and repeat the process - each time one step further, each time paving the way for the next step.</p>\n<p>In order to accomodate with this philosophy, the v2 received fundamental changes that turned Yarn into an actual Javascript API as much as a CLI. Additionally, the CLI got reworked so that user scripts can be interconnected with Yarn's core components and extend the tool with new features. We call them plugins and, in fact, you already use them - most commands such as <code>yarn add</code> are implemented through plugins!</p>\n<h2>What can plugins do?</h2>\n<ul>\n<li>\n<p><strong>Plugins can add new resolvers.</strong> Resolvers are the components tasked from converting dependency ranges (for example <code>^1.2.0</code>) into fully-qualified package references (for example <code>npm:1.2.0</code>). By implementing a resolver, you can tell Yarn which versions are valid candidate to a specific range.</p>\n</li>\n<li>\n<p><strong>Plugins can add new fetchers.</strong> Fetchers are the components that take the fully-qualified package references we mentioned in the previous step and find their location on the disk. Fetchers can work with remote packages (for example by downloading the files from a registry), but can also find the packages directly on the disk (like we do for the <code>file:</code> and <code>portal:</code> protocols).</p>\n</li>\n<li>\n<p><strong>Plugins can add new linkers.</strong> Once all the packages have been located and are ready for installation, Yarn will call the linkers to generate the files needed for the install targets to work properly. The PnP linker will generate its <code>.pnp.js</code> files, while a Python linker would generate the virtualenv files needed.</p>\n</li>\n<li>\n<p><strong>Plugins can add new commands.</strong> Each plugin can ship as many commands as they see fit, which will be injected into our CLI (including via <code>yarn --help</code>). The main benefit you have with exposing tools this way rather than using them through <code>yarn run &#x3C;tool-name></code> is that your plugin gets dynamically linked within the Yarn context, meaning that you're sure to use the exact same component versions as the one used by your user.</p>\n</li>\n</ul>\n<p>And of course, plugins can add new configuration settings as they see fit - Yarn will throw an exception if it finds a configuration settings that isn't supported by any plugin, which prevents users from accidentally depending on a plugin that doesn't exist.</p>\n<h2>How to use plugins?</h2>\n<p>Plugins are single-file JS scripts built via the <code>@berry/builder</code> tools. They are relatively easy to use (we plan to improve it even more by wrapping the process within a CLI command):</p>\n<ul>\n<li>\n<p>Download the plugin you want to use and put it somewhere within your project</p>\n</li>\n<li>\n<p>Update your project-level <code>.yarnrc</code> file by adding the following property:</p>\n<pre><code>plugins:\n  - \"./my-plugin.js\"\n</code></pre>\n</li>\n</ul>\n<p>And that's it! The next time you'll start Yarn, your plugin will be injected into the environment.</p>","frontmatter":{"path":"/features/plugins","title":"Plugins"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"features"}}