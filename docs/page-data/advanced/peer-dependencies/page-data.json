{"componentChunkName":"component---src-templates-article-js","path":"/advanced/peer-dependencies","webpackCompilationHash":"38f18c79d960bb0f9967","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/advanced/architecture","title":"Architecture"}}},{"node":{"frontmatter":{"path":"/advanced/contributing","title":"Contributing"}}},{"node":{"frontmatter":{"path":"/advanced/error-codes","title":"Error Codes"}}},{"node":{"frontmatter":{"path":"/advanced/lexicon","title":"Lexicon"}}},{"node":{"frontmatter":{"path":"/advanced/migration","title":"Migration"}}},{"node":{"frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}},{"node":{"frontmatter":{"path":"/advanced/plugin-tutorial","title":"Plugin Tutorial"}}},{"node":{"frontmatter":{"path":"/advanced/pnpapi","title":"PnP API"}}},{"node":{"frontmatter":{"path":"/advanced/pnpify","title":"PnPify"}}}]},"markdownRemark":{"html":"<p>The PnP linker guarantees that each combination of package name / version will only be instantiated once, except in one documented case: if a package has peer dependencies. Such ones will be instantiated once <em>for each time a hard dependency is found in the dependency tree</em>.</p>\n<p>For example, let's say you have <code class=\"language-text\">react</code> and <code class=\"language-text\">react-dom</code>. Since the <code class=\"language-text\">react</code> package doesn't list any peer dependencies, a same version of <code class=\"language-text\">react</code> will only ever be instantiated once regardless how many dependent packages list it in their <code class=\"language-text\">dependencies</code> field. However, because <code class=\"language-text\">react-dom</code> lists <code class=\"language-text\">react</code> within its <code class=\"language-text\">peerDependencies</code> field, Yarn will need to install it in such a way that it will be instantiated exactly once for each package that list it in their <code class=\"language-text\">dependencies</code> field.</p>\n<h2 id=\"why-does-it-work-this-way\"><a href=\"#why-does-it-work-this-way\" aria-label=\"why does it work this way permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why does it work this way?</h2>\n<p>Let's say you have <code class=\"language-text\">package-a</code> and <code class=\"language-text\">package-b</code>. Both of them depend on the same package <code class=\"language-text\">child</code>, which has a peer dependency on <code class=\"language-text\">peer</code>. Now, imagine that <code class=\"language-text\">package-a</code> depends on <code class=\"language-text\">peer@1</code> while <code class=\"language-text\">package-b</code> depends on <code class=\"language-text\">peer@2</code>. In this instance, in order to respect the peer dependency requirement, <code class=\"language-text\">child</code> will have to be instantiated - it wouldn't be possible otherwise for <code class=\"language-text\">child</code> to simultaneously use both <code class=\"language-text\">package-a</code> and <code class=\"language-text\">package-b</code>.</p>\n<p>In order to make sure that <code class=\"language-text\">child</code> will get instantiated twice, we generate what we call \"virtual packages\". A virtual packages simply is an additional instance of a package, that points to the same location on the disk but will have its own in-memory representation. In order to generate those virtual packages, we need them to give each of them a unique identifier. Now, what information could we use to do this?</p>\n<p>The first thing you might think of could be something along those lines: \"the unique identifier for a virtual package must be based on its set of inherited dependencies\". So in our example, since <code class=\"language-text\">child</code> has two sets of inherited dependencies, it would get two unique identifiers, would be instantiated twice, and everything would work. Additionally, if <code class=\"language-text\">package-a</code> and <code class=\"language-text\">package-b</code> happened to depend on the same version of <code class=\"language-text\">peer</code> then we would only generate one virtual package, which would decrease the tree complexity. Unfortunately, it's not so simple.</p>\n<p>Problems arise when you consider circular dependencies. Let's imagine a different scenario: <code class=\"language-text\">package</code> depends on <code class=\"language-text\">child-a</code> and <code class=\"language-text\">child-b</code>. The <code class=\"language-text\">child-a</code> package has a peer dependency on <code class=\"language-text\">child-b</code>, and <code class=\"language-text\">child-b</code> has a peer dependency on <code class=\"language-text\">child-a</code>. In this situation, per the wording described above, we would need to generate the unique identifier for <code class=\"language-text\">child-a</code> based on the set of its dependencies, which includes <code class=\"language-text\">child-b</code>. But since the unique identifier for <code class=\"language-text\">child-b</code> depends on the one from <code class=\"language-text\">child-a</code>, we cannot do that! The loop cannot be broken this way.</p>\n<p>The solution to this issue is to say that the unique identifier for a package with peer dependencies is based on the unique identifier of its <em>direct parent</em>. Since a package unique identifier is always computed before its children (which also happens to be the reason why peer dependencies must be explicitly listed at every level of the dependency hierarchy), we cannot have a cyclic dependency.</p>\n<h2 id=\"how-to-prevent-multiple-instantiation\"><a href=\"#how-to-prevent-multiple-instantiation\" aria-label=\"how to prevent multiple instantiation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to prevent multiple instantiation?</h2>\n<p>In some cases you really don't want a package to be instantiated twice. It can be because you're using <code class=\"language-text\">instanceof</code> on user-provided objects (which would break for similar objects from different instances), or because your code has side effects (for example by having a singleton).</p>\n<p>In general we simply discourage the use of these patterns. They are quite dangerous, and it's hard to know for sure whether your package will really be instantiated once (while Yarn can make such guarantees, other package managers might not). Still, it might also be difficult to change immediatly, so you have a few tools at your disposal:</p>\n<ul>\n<li>\n<p>You can move the code managing your singleton inside its own package. So for example in the case of <code class=\"language-text\">relay-runtime</code> (which has a singleton and a peer dependency on <code class=\"language-text\">relay-compiler</code>) one solution would to move the singleton into a dedicated package that wouldn't have any peer dependency. Since Yarn guarantees that a single package name / version is always instantiated once in such cases, your singleton would be safe.</p>\n</li>\n<li>\n<p>Maybe simpler, your singleton can also be stored within the global context, using an identifier unique to your application. This might actually be even safer than what you currently do, because you'd then be able to properly check for multiple conflicting versions being used:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const myVersion = require(&#39;./package.json&#39;).version;\n\nfunction makeSingleton() {\n  return {\n    value: new Something(),\n    version: myVersion,\n  };\n}\n\nexport function getSingleton() {\n  // Note that symbols cannot be used, as each package instance would have\n  // a different symbol instance\n  if (!global.singleton)\n    global.singleton = makeSingleton();\n\n  const {value, version} = global.singleton;\n  console.assert(version === myVersion);\n\n  return value;\n}</code></pre></div>\n</li>\n</ul>","frontmatter":{"path":"/advanced/peer-dependencies","title":"Peer Dependencies"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"category":"advanced"}}}